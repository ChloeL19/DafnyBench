

========
Experiment configuration: python experiments.py --experiment_name run_diversity.py --n_trials 10 --mins_timeout 10 --language Dafny --problem_name problem_opt0_opt --seed 42 --base_model_name ./my_dpo_model 


To complete all experiments, 0 minutes and 0 seconds elapsed.




========
Experiment configuration: python experiments.py --experiment_name run_diversity.py --n_trials 10 --mins_timeout 10 --language Dafny --problem_name problem_opt0_opt --seed 42 --base_model_name ./my_dpo_model 


[2024-01-12 15:53:20,347] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = \n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(i: int)\n', 'datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(value: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)

SCORE
1.0
['  | Const(n: int)\n', '  | Const(value: int)\n', '  | Const(n: int)\n', '  | Const(val: int)\n', '  | Const(i: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e {\n', '  match e\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
8 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
9 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(9,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                 ^

ex.dfy(10,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
11 |   case _ => true
   |                 ^

ex.dfy(11,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
16 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
17 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(18,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
19 |   case _ => e
   |              ^

ex.dfy(19,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e

   |
25 |   match e
   |          ^

ex.dfy(25,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                 ^

ex.dfy(26,48): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
27 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n', '  case _ => \n', '  case _ =>\n', '  case _ => \n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 

   |
27 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n', '  case _ => \n', '  case _ => \n', '  case _ => \n', '  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                 ^

ex.dfy(27,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) =>

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(27,28): Error: missing semicolon at end of statement
   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) => 

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(27,28): Error: missing semicolon at end of statement
   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) => \n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}

   |
26 |   case Add(Const(0), e2) => {}
   |                               ^

ex.dfy(26,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>

   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => {}\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}

   |
27 |   case Add(e1, Const(0)) => {}
   |                               ^

ex.dfy(27,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {

   |
28 |   case Add(e1, e2) => {
   |                        ^

ex.dfy(28,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => {\n', '  case Add(e1, e2) => {\n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) => {\n', '  case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  }
  case _ => {}

   |
32 |   case _ => {}
   |               ^

ex.dfy(32,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => {}\n', '  case _ => {}\n', '  case _ => {}\n', '  case _ => {}\n', '  case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  }
  case _ => {}
}

ex.dfy(26,21): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5299,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
27 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(27,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions

   |
27 |     // recursive call on sub-expressions
   |                                         ^

ex.dfy(27,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    // recursive call on sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions
    OptimizerOptimal(e1);

   |
28 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
29 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
30 |   case _ =>
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
30 |   case _ =>
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n', '  case _ => \n', '  case _ => \n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
    // base case

   |
31 |     // base case
   |                 ^

ex.dfy(31,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '    // base case\n', '    // base case\n', '}\n', '    // base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    // recursive call on sub-expressions
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
    // base case
}

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => {}\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) => \n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ => \n', '  case _ =>\n', '  case _ => \n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
28 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
29 |   case _ =>
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  }

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['  }\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) => \n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n', '  case _ => \n', '  case _ => \n', '  case _ => \n', '  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n', '  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) => \n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n', '  case _ => \n', '  case _ => \n', '  case _ => \n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => \n', '  case Add(Const(0), e2) => \n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n', '  case _ =>\n', '  case _ => \n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e {\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 41
number of gen nodes: 21 (including leaves: 7)
number of back nodes: 20 (including leaves: 14)

expansion count: 33 (including failed: 13)

cache stats {'hit': 664, 'miss': 96}
calls to generate 152
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610]

Trial calls: [760]


Time Statistics:

  Min: 610.00 sec, Max: 610.00 sec, Average: 610.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 760 calls, Max: 760 calls, Average: 760.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610]

Trial calls: [760]


Time Statistics:

  Min: 610.00 sec, Max: 610.00 sec, Average: 610.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 760 calls, Max: 760 calls, Average: 760.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
['datatype Expr =\n', 'datatype Expr =\n', 'datatype Expr = \n', 'datatype Expr = Const(n: int)\n', 'datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(value: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)

SCORE
1.0
['  | Const(value: int)\n', '  | Const(n: int)\n', '  | Const(value: int)\n', '  | Const(i: int)\n', '  | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
15 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
16 |   match e {
   |            ^

ex.dfy(16,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
17 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
18 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
19 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(19,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
21 |   }
   |    ^

ex.dfy(21,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(29,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 47
number of gen nodes: 24 (including leaves: 7)
number of back nodes: 23 (including leaves: 17)

expansion count: 37 (including failed: 14)

cache stats {'hit': 807, 'miss': 43}
calls to generate 170
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616]

Trial calls: [760, 850]


Time Statistics:

  Min: 610.00 sec, Max: 616.00 sec, Average: 613.00 sec, Standard Deviation: 3.00 sec

Call Statistics:

  Min: 760 calls, Max: 850 calls, Average: 805.00 calls, Standard Deviation: 45.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616]

Trial calls: [760, 850]


Time Statistics:

  Min: 610.00 sec, Max: 616.00 sec, Average: 613.00 sec, Standard Deviation: 3.00 sec

Call Statistics:

  Min: 760 calls, Max: 850 calls, Average: 805.00 calls, Standard Deviation: 45.00 calls

Trial  3
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr =\n', 'datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = Const(n: int)\n', 'datatype Expr = \n', 'datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)

SCORE
1.0
['  | Const(val: int)\n', '  | Const(i: int)\n', '  | Const(v: int)\n', '  | Const(v: int)\n', '  | Const(n: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(n: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)

SCORE
1.0
['  | Var(n: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(x: string)\n', '  | Var(n: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
15 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
16 |   match e {
   |            ^

ex.dfy(16,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
17 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
18 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
19 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(19,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
21 |   }
   |    ^

ex.dfy(21,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(29,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 47
number of gen nodes: 24 (including leaves: 7)
number of back nodes: 23 (including leaves: 17)

expansion count: 37 (including failed: 14)

cache stats {'hit': 828, 'miss': 47}
calls to generate 175
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629]

Trial calls: [760, 850, 875]


Time Statistics:

  Min: 610.00 sec, Max: 629.00 sec, Average: 618.33 sec, Standard Deviation: 7.93 sec

Call Statistics:

  Min: 760 calls, Max: 875 calls, Average: 828.33 calls, Standard Deviation: 49.39 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629]

Trial calls: [760, 850, 875]


Time Statistics:

  Min: 610.00 sec, Max: 629.00 sec, Average: 618.33 sec, Standard Deviation: 7.93 sec

Call Statistics:

  Min: 760 calls, Max: 875 calls, Average: 828.33 calls, Standard Deviation: 49.39 calls

Trial  4
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int)

SCORE
1.0
['datatype Expr = Const(n: int)\n', 'datatype Expr = Const(i: int)\n', 'datatype Expr =\n', 'datatype Expr =\n', 'datatype Expr = Const(v: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)

SCORE
1.0
['              | Var(x: string)\n', '              | Var(x: string)\n', '             | Var(x: string)\n', '              | Var(x: string)\n', '              | Var(x: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
5 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(5,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
6 |   match e
  |          ^

ex.dfy(6,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
7 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(7,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
8 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
9 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                 ^

ex.dfy(9,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
10 |   case _ => true
   |                 ^

ex.dfy(10,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
13 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
14 |   match e
   |          ^

ex.dfy(14,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
15 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(15,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n', '  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
16 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n', '  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
17 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(17,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
18 |   case _ => e
   |              ^

ex.dfy(18,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n', '  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e

   |
24 |   match e
   |          ^

ex.dfy(24,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>

   |
25 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(25,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}

   |
25 |   case Add(Const(0), e2) => {}
   |                               ^

ex.dfy(25,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => {}\n', '  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
26 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
27 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(27,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
28 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
29 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
30 |   case _ =>
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>

   |
25 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(25,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
25 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                 ^

ex.dfy(25,48): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) => {}\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}

   |
26 |   case Add(e1, Const(0)) => {}
   |                               ^

ex.dfy(26,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n', '  case Add(e1, Const(0)) => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) =>

   |
27 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(27,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {

   |
27 |   case Add(e1, e2) => {
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) => {\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) => {\n', '  case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);

   |
28 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
29 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  }
  case _ => {}

   |
31 |   case _ => {}
   |               ^

ex.dfy(31,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => {}\n', '  case _ => {}\n', '  case _ => {}\n', '  case _ => {}\n', '  case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => {
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  }
  case _ => {}
}

ex.dfy(25,21): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5299,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
26 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(26,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
27 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(27,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
28 |   case _ =>
   |            ^

ex.dfy(28,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  }

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;

   |
29 |   ;
   |   ^

ex.dfy(29,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  {}

   |
29 |   {}
   |     ^

ex.dfy(29,4): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '  }\n', '  ;\n', '  {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}

   |
29 |   ;
   |   ^

ex.dfy(29,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}
``` #ifndef PYTHONIC_INCLUDE_TYPES_NUMPY_EXPR_HPP

   |
29 |   ;
   |   ^

ex.dfy(29,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}
``` import { Component, OnInit, OnDestroy, Input } from '@angular/core';

   |
29 |   ;
   |   ^

ex.dfy(29,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}
``` package com.google.common.truth;

   |
29 |   ;
   |   ^

ex.dfy(29,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}
``` <?php

   |
29 |   ;
   |   ^

ex.dfy(29,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}
``` import React, { Component } from "react";

   |
29 |   ;
   |   ^

ex.dfy(29,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['``` #ifndef PYTHONIC_INCLUDE_TYPES_NUMPY_EXPR_HPP\n', "``` import { Component, OnInit, OnDestroy, Input } from '@angular/core';\n", '``` package com.google.common.truth;\n', '``` <?php\n', '``` import React, { Component } from "react";\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // base case

   |
29 |   // base case
   |               ^

ex.dfy(29,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  ;\n', '}\n', '  {}\n', '  ;\n', '  // base case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // base case
}

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
25 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(25,28): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                 ^

ex.dfy(26,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) =>

   |
25 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(25,28): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(27,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e

   |
29 |   // Base case: If e is not an addition, then the optimized version of e
   |                                                                         ^

ex.dfy(29,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '  ;\n', '  // Base case: If e is not an addition, then the optimized version of e\n', '  ;\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is just e itself, and the predicate optimal is trivially true for e.

   |
30 |   // is just e itself, and the predicate optimal is trivially true for e.
   |                                                                          ^

ex.dfy(30,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is just e itself, so it's vacuously true that the optimized version is optimal.

   |
30 |   // is just e itself, so it's vacuously true that the optimized version is optimal.
   |                                                                                     ^

ex.dfy(30,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one

   |
30 |   // is either a constant, a variable, or an addition where at least one
   |                                                                         ^

ex.dfy(30,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is just e itself. Since e is not an addition, the predicate optimal

   |
30 |   // is just e itself. Since e is not an addition, the predicate optimal
   |                                                                         ^

ex.dfy(30,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is just e itself, and the predicate optimal holds for e iff it holds

   |
30 |   // is just e itself, and the predicate optimal holds for e iff it holds
   |                                                                          ^

ex.dfy(30,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // is just e itself, and the predicate optimal is trivially true for e.\n', "  // is just e itself, so it's vacuously true that the optimized version is optimal.\n", '  // is either a constant, a variable, or an addition where at least one\n', '  // is just e itself. Since e is not an addition, the predicate optimal\n', '  // is just e itself, and the predicate optimal holds for e iff it holds\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is

   |
31 |   // of the sub-expressions has been optimized. But since optimal is
   |                                                                     ^

ex.dfy(31,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. In any case, the optimized

   |
31 |   // of the sub-expressions has been optimized. In any case, the optimized
   |                                                                           ^

ex.dfy(31,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since we know that

   |
31 |   // of the sub-expressions has been optimized. But since we know that
   |                                                                       ^

ex.dfy(31,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions is not an addition by 0. Thus, it is optimal.

   |
31 |   // of the sub-expressions is not an addition by 0. Thus, it is optimal.
   |                                                                          ^

ex.dfy(31,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions is not 0. In each of these cases, optimal(e)

   |
31 |   // of the sub-expressions is not 0. In each of these cases, optimal(e)
   |                                                                         ^

ex.dfy(31,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // of the sub-expressions has been optimized. But since optimal is\n', '  // of the sub-expressions has been optimized. In any case, the optimized\n', '  // of the sub-expressions has been optimized. But since we know that\n', '  // of the sub-expressions is not an addition by 0. Thus, it is optimal.\n', '  // of the sub-expressions is not 0. In each of these cases, optimal(e)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // preserved under optimization, it follows that the optimized version

   |
32 |   // preserved under optimization, it follows that the optimized version
   |                                                                         ^

ex.dfy(32,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // defined such that it holds for constants, variables, and optimized

   |
32 |   // defined such that it holds for constants, variables, and optimized
   |                                                                        ^

ex.dfy(32,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // preserved under optimization, we have optimal(optimize(e)).

   |
32 |   // preserved under optimization, we have optimal(optimize(e)).
   |                                                                 ^

ex.dfy(32,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // defined to hold for these cases, the lemma follows by structural

   |
32 |   // defined to hold for these cases, the lemma follows by structural
   |                                                                      ^

ex.dfy(32,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // defined such that it holds for any expression, it must hold for the

   |
32 |   // defined such that it holds for any expression, it must hold for the
   |                                                                         ^

ex.dfy(32,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // preserved under optimization, it follows that the optimized version\n', '  // defined such that it holds for constants, variables, and optimized\n', '  // preserved under optimization, we have optimal(optimize(e)).\n', '  // defined to hold for these cases, the lemma follows by structural\n', '  // defined such that it holds for any expression, it must hold for the\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // defined to hold for these cases, the lemma follows by structural
  // induction.

   |
33 |   // induction.
   |                ^

ex.dfy(33,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // defined to hold for these cases, the lemma follows by structural
  // induction on the shape of the expression.

   |
33 |   // induction on the shape of the expression.
   |                                               ^

ex.dfy(33,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // induction.\n', '  // induction.\n', '  // induction on the shape of the expression.\n', '  // induction.\n', '  // induction.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  // Base case: If e is not an addition, then the optimized version of e
  // is either a constant, a variable, or an addition where at least one
  // of the sub-expressions has been optimized. But since optimal is
  // defined to hold for these cases, the lemma follows by structural
  // induction on the shape of the expression.
}

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(e1, e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(e1, e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  end

   |
29 |   end
   |      ^

ex.dfy(29,5): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  end\n', '  {}\n', '  {}\n', '  ;\n', '  {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  end
}

   |
29 |   end
   |   ^^^

ex.dfy(29,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  end
}
```

   |
29 |   end
   |   ^^^

ex.dfy(29,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  end
}
``` package io.github.lucasstarsz.fastj.math.geom;

   |
29 |   end
   |   ^^^

ex.dfy(29,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  end
}
``` #import <UIKit/UIKit.h>

   |
29 |   end
   |   ^^^

ex.dfy(29,2): Error: missing semicolon at end of statement
1 parse errors detected in ex.dfy

SCORE
-1.0
['```\n', '``` package io.github.lucasstarsz.fastj.math.geom;\n', '```\n', '```\n', '``` #import <UIKit/UIKit.h>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
['  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) =>\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n', '  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n', '  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n', '    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n', '    OptimizerOptimal(e2);\n']
['  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n', '  case _ =>\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
14 |   match e {
   |            ^

ex.dfy(14,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e\n', '  match e\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
15 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
16 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
17 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(17,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
18 |     case _ => e
   |                ^

ex.dfy(18,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
19 |   }
   |    ^

ex.dfy(19,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
             | Var(x: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 41
number of gen nodes: 21 (including leaves: 7)
number of back nodes: 20 (including leaves: 14)

expansion count: 33 (including failed: 13)

cache stats {'hit': 660, 'miss': 95}
calls to generate 151
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603]

Trial calls: [760, 850, 875, 755]


Time Statistics:

  Min: 603.00 sec, Max: 629.00 sec, Average: 614.50 sec, Standard Deviation: 9.55 sec

Call Statistics:

  Min: 755 calls, Max: 875 calls, Average: 810.00 calls, Standard Deviation: 53.27 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603]

Trial calls: [760, 850, 875, 755]


Time Statistics:

  Min: 603.00 sec, Max: 629.00 sec, Average: 614.50 sec, Standard Deviation: 9.55 sec

Call Statistics:

  Min: 755 calls, Max: 875 calls, Average: 810.00 calls, Standard Deviation: 53.27 calls

Trial  5
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = \n', 'datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = Const(n: int)\n', 'datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(value: int)

SCORE
1.0
['  | Const(val: int)\n', '  | Const(val: int)\n', '  | Const(n: int)\n', '  | Const(i: int)\n', '  | Const(value: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
8 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
9 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(9,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                 ^

ex.dfy(10,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
11 |   case _ => true
   |                 ^

ex.dfy(11,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e {\n', '  match e\n', '  match e\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
26 |   match e {
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(27,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n', '    case _ => \n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
27 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(27,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)

   |
28 |       // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
   |                                                               ^

ex.dfy(28,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The lemma holds because optimize(e) simplifies the addition by removing 0.

   |
28 |       // The lemma holds because optimize(e) simplifies the addition by removing 0.
   |                                                                                    ^

ex.dfy(28,83): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)\n', '      OptimizerOptimal(e2);\n', '      // The lemma holds because optimize(e) simplifies the addition by removing 0.\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize

   |
29 |       // By definition of optimize
   |                                   ^

ex.dfy(29,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      // By definition of optimize\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);

   |
30 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }

   |
31 |     }
   |      ^

ex.dfy(31,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
32 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(32,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)

   |
33 |       // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
   |                                                               ^

ex.dfy(33,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize

   |
34 |       // By definition of optimize
   |                                   ^

ex.dfy(34,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);

   |
35 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }

   |
36 |     }
   |      ^

ex.dfy(36,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
37 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(37,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))

   |
38 |       // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
   |                                                                                 ^

ex.dfy(38,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 

   |
38 |       // Inductive case:
   |                         ^

ex.dfy(38,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // Inductive case: \n', '      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))

   |
39 |       // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
   |                                                                 ^

ex.dfy(39,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))

   |
39 |       // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
   |                                                                                   ^

ex.dfy(39,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))\n', '      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize

   |
40 |       // By definition of optimize
   |                                   ^

ex.dfy(40,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);

   |
41 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(41,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
42 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(42,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
43 |     }
   |      ^

ex.dfy(43,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {

   |
44 |     case _ => {
   |                ^

ex.dfy(44,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()

   |
44 |     case _ => ()
   |                 ^

ex.dfy(44,16): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n', '    case _ => ()\n', '    case _ => {\n', '    case _ => ()\n', '    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }

   |
45 |   }
   |   ^

ex.dfy(45,2): Error: invalid Suffix
   |
44 |     case _ => ()
   |               ^

ex.dfy(44,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}

   |
45 |   }
   |   ^

ex.dfy(45,2): Error: invalid Suffix
   |
44 |     case _ => ()
   |               ^

ex.dfy(44,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
```

   |
45 |   }
   |   ^

ex.dfy(45,2): Error: invalid Suffix
   |
44 |     case _ => ()
   |               ^

ex.dfy(44,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` package com.example.android.architecture.blueprints.todoapp.data.source

   |
45 |   }
   |   ^

ex.dfy(45,2): Error: invalid Suffix
   |
44 |     case _ => ()
   |               ^

ex.dfy(44,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` package com.example.administrator.myapplication.Utils;

   |
45 |   }
   |   ^

ex.dfy(45,2): Error: invalid Suffix
   |
44 |     case _ => ()
   |               ^

ex.dfy(44,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` package com.github.jcustenborder.kafka.connect.spooldir;

   |
45 |   }
   |   ^

ex.dfy(45,2): Error: invalid Suffix
   |
44 |     case _ => ()
   |               ^

ex.dfy(44,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: 
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` package com.example.android.miwok;

   |
45 |   }
   |   ^

ex.dfy(45,2): Error: invalid Suffix
   |
44 |     case _ => ()
   |               ^

ex.dfy(44,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['```\n', '``` package com.example.android.architecture.blueprints.todoapp.data.source\n', '``` package com.example.administrator.myapplication.Utils;\n', '``` package com.github.jcustenborder.kafka.connect.spooldir;\n', '``` package com.example.android.miwok;\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n', '    case _ => \n', '    case _ => \n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => 

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => 
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ => \n', '    case _ =>\n', '    case _ => \n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => {\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ => \n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '      OptimizerOptimal(e2);\n', '    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) => 

   |
31 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) =>

   |
31 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
32 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
33 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
34 |     case _ =>
   |              ^

ex.dfy(34,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
34 |     case _ =>
   |              ^

ex.dfy(34,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n', '    case _ => \n', '    case _ =>\n', '    case _ => \n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
35 |   }
   |    ^

ex.dfy(35,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5304,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => {\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive calls for sub-expressions

   |
28 |       // Recursive calls for sub-expressions
   |                                             ^

ex.dfy(28,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive call for sub-expressions

   |
28 |       // Recursive call for sub-expressions
   |                                            ^

ex.dfy(28,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      // Recursive calls for sub-expressions\n', '      // Recursive call for sub-expressions\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive calls for sub-expressions
      OptimizerOptimal(e1);

   |
29 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive calls for sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
30 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive calls for sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive calls for sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n', '    case _ => \n', '    case _ => \n', '    case _ =>\n', '    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive calls for sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
32 |   }
   |    ^

ex.dfy(32,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive calls for sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => \n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0

   |
28 |       // In this case, the optimization removes the addition by 0
   |                                                                  ^

ex.dfy(28,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n', '      // In this case, the optimization removes the addition by 0\n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n', '    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0

   |
30 |       // In this case, the optimization removes the addition by 0
   |                                                                  ^

ex.dfy(30,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, the optimization removes the addition by 0\n', '      // In this case, the optimization removes the addition by 0\n', '      // In this case, the optimization removes the addition by 0\n', '      // In this case, the optimization removes the addition by 0\n', '      // In this case, the optimization removes the addition by 0\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 

   |
31 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) =>

   |
31 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // In this case, the optimization recursively optimizes the sub-expressions

   |
32 |       // In this case, the optimization recursively optimizes the sub-expressions
   |                                                                                  ^

ex.dfy(32,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively

   |
32 |       // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
   |                                                                                               ^

ex.dfy(32,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, the optimization recursively optimizes the sub-expressions\n', '      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively\n', '      // In this case, the optimization recursively optimizes the sub-expressions\n', '      // In this case, the optimization recursively optimizes the sub-expressions\n', '      // In this case, the optimization recursively optimizes the sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);

   |
33 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
34 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(34,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
35 |     case _ =>
   |              ^

ex.dfy(35,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n', '    case _ => \n', '    case _ => \n', '    case _ => \n', '    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
      // Base case: we have a constant or a variable, which are always optimal

   |
36 |       // Base case: we have a constant or a variable, which are always optimal
   |                                                                               ^

ex.dfy(36,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
      // Base case: nothing changes

   |
36 |       // Base case: nothing changes
   |                                    ^

ex.dfy(36,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
      // Base case: we don't do any optimization, so the expression is already optimal

   |
36 |       // Base case: we don't do any optimization, so the expression is already optimal
   |                                                                                       ^

ex.dfy(36,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
      // Base case: we do nothing as the expression is already optimized

   |
36 |       // Base case: we do nothing as the expression is already optimized
   |                                                                         ^

ex.dfy(36,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: we have a constant or a variable, which are always optimal\n', '      // Base case: nothing changes\n', "      // Base case: we don't do any optimization, so the expression is already optimal\n", '      // Base case: we do nothing as the expression is already optimized\n', '      // Base case: nothing changes\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
      // Base case: we have a constant or a variable, which are always optimal
  }

   |
37 |   }
   |    ^

ex.dfy(37,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, Const(0)) => 
      // In this case, the optimization removes the addition by 0
    case Add(e1, e2) => 
      // Recursive case: we optimize the sub-expressions and then we use the lemma recursively
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
      // Base case: we have a constant or a variable, which are always optimal
  }
}

ex.dfy(31,4): Error: a postcondition could not be proved on this return path
   |
31 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(31,4): Error: a postcondition could not be proved on this return path
   |
31 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(31,4): Error: a postcondition could not be proved on this return path
   |
31 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(31,4): Error: a postcondition could not be proved on this return path
   |
31 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(31,4): Error: a postcondition could not be proved on this return path
   |
31 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 35
number of gen nodes: 18 (including leaves: 5)
number of back nodes: 17 (including leaves: 13)

expansion count: 28 (including failed: 11)

cache stats {'hit': 592, 'miss': 143}
calls to generate 147
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653]

Trial calls: [760, 850, 875, 755, 735]


Time Statistics:

  Min: 603.00 sec, Max: 653.00 sec, Average: 622.20 sec, Standard Deviation: 17.61 sec

Call Statistics:

  Min: 735 calls, Max: 875 calls, Average: 795.00 calls, Standard Deviation: 56.30 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653]

Trial calls: [760, 850, 875, 755, 735]


Time Statistics:

  Min: 603.00 sec, Max: 653.00 sec, Average: 622.20 sec, Standard Deviation: 17.61 sec

Call Statistics:

  Min: 735 calls, Max: 875 calls, Average: 795.00 calls, Standard Deviation: 56.30 calls

Trial  6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = \n', 'datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
3 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(3,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
5 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(5,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
6 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(6,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                   ^

ex.dfy(7,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

  |
8 |     case _ => true
  |                   ^

ex.dfy(8,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

  |
9 |   }
  |    ^

ex.dfy(9,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
12 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
13 |   match e {
   |            ^

ex.dfy(13,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
14 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
15 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
16 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(16,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
17 |     case _ => e
   |                ^

ex.dfy(17,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
18 |   }
   |    ^

ex.dfy(18,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
24 |   match e {
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
25 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
25 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(25,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
26 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(26,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(25,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ =>
   |              ^

ex.dfy(26,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ => ()
   |                 ^

ex.dfy(26,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => {}

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ => {}
   |                 ^

ex.dfy(26,16): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ => ()\n', '    case _ => {}\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()
  }

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
27 |   }
   |   ^

ex.dfy(27,2): Error: invalid Suffix
   |
26 |     case _ => ()
   |               ^

ex.dfy(26,14): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
26 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(26,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
25 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(25,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we use the lemma recursively without asserts.

   |
26 |       // Here, we use the lemma recursively without asserts.
   |                                                             ^

ex.dfy(26,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing else to prove, by definition of optimize

   |
26 |       // nothing else to prove, by definition of optimize
   |                                                          ^

ex.dfy(26,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case for optimization: e1 is 0.

   |
26 |       // Base case for optimization: e1 is 0.
   |                                              ^

ex.dfy(26,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal

   |
26 |       // nothing to optimize, so it's optimal
   |                                              ^

ex.dfy(26,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Here, we use the lemma recursively without asserts.\n', '      // nothing else to prove, by definition of optimize\n', '      OptimizerOptimal(e2);\n', '      // Base case for optimization: e1 is 0.\n', "      // nothing to optimize, so it's optimal\n"]
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }

   |
27 |     }
   |      ^

ex.dfy(27,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {

   |
28 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal

   |
29 |       // nothing to optimize, so it's optimal
   |                                              ^

ex.dfy(29,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      // nothing to optimize, so it's optimal\n", "      // nothing to optimize, so it's optimal\n", "      // nothing to optimize, so it's optimal\n", "      // nothing to optimize, so it's optimal\n", "      // nothing to optimize, so it's optimal\n"]
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }

   |
30 |     }
   |      ^

ex.dfy(30,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {

   |
31 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(31,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively optimize sub-expressions

   |
32 |       // recursively optimize sub-expressions
   |                                              ^

ex.dfy(32,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality

   |
32 |       // recursively prove optimality
   |                                      ^

ex.dfy(32,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality for sub-expressions

   |
32 |       // recursively prove optimality for sub-expressions
   |                                                          ^

ex.dfy(32,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove the lemma for the optimized sub-expressions

   |
32 |       // recursively prove the lemma for the optimized sub-expressions
   |                                                                       ^

ex.dfy(32,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality for the sub-expressions

   |
32 |       // recursively prove optimality for the sub-expressions
   |                                                              ^

ex.dfy(32,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // recursively optimize sub-expressions\n', '      // recursively prove optimality\n', '      // recursively prove optimality for sub-expressions\n', '      // recursively prove the lemma for the optimized sub-expressions\n', '      // recursively prove optimality for the sub-expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);

   |
33 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
34 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(34,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
35 |     }
   |      ^

ex.dfy(35,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {

   |
36 |     case _ => {
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case: variables and constants are always optimal

   |
37 |       // base case: variables and constants are always optimal
   |                                                               ^

ex.dfy(37,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // other cases are trivially optimal

   |
37 |       // other cases are trivially optimal
   |                                           ^

ex.dfy(37,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case: it's a constant or a variable, so it's optimal

   |
37 |       // base case: it's a constant or a variable, so it's optimal
   |                                                                   ^

ex.dfy(37,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case: it's a variable or constant, which is always optimal

   |
37 |       // base case: it's a variable or constant, which is always optimal
   |                                                                         ^

ex.dfy(37,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // constants and variables are always optimal

   |
37 |       // constants and variables are always optimal
   |                                                    ^

ex.dfy(37,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // base case: variables and constants are always optimal\n', '      // other cases are trivially optimal\n', "      // base case: it's a constant or a variable, so it's optimal\n", "      // base case: it's a variable or constant, which is always optimal\n", '      // constants and variables are always optimal\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case: variables and constants are always optimal
    }

   |
38 |     }
   |      ^

ex.dfy(38,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case: variables and constants are always optimal
    }
  }

   |
39 |   }
   |    ^

ex.dfy(39,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize, so it's optimal
    }
    case Add(e1, e2) => {
      // recursively prove optimality
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case: variables and constants are always optimal
    }
  }
}

ex.dfy(25,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5299,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(27,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>
  }

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => {\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => {\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 43
number of gen nodes: 22 (including leaves: 7)
number of back nodes: 21 (including leaves: 15)

expansion count: 34 (including failed: 13)

cache stats {'hit': 698, 'miss': 82}
calls to generate 156
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603]

Trial calls: [760, 850, 875, 755, 735, 780]


Time Statistics:

  Min: 603.00 sec, Max: 653.00 sec, Average: 619.00 sec, Standard Deviation: 17.60 sec

Call Statistics:

  Min: 735 calls, Max: 875 calls, Average: 792.50 calls, Standard Deviation: 51.70 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603]

Trial calls: [760, 850, 875, 755, 735, 780]


Time Statistics:

  Min: 603.00 sec, Max: 653.00 sec, Average: 619.00 sec, Standard Deviation: 17.60 sec

Call Statistics:

  Min: 735 calls, Max: 875 calls, Average: 792.50 calls, Standard Deviation: 51.70 calls

Trial  7
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = Const(i: int)\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
3 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(3,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
4 |   match e
  |          ^

ex.dfy(4,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e {\n', '  match e\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
5 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(5,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
6 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(6,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                 ^

ex.dfy(7,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

  |
8 |   case _ => true
  |                 ^

ex.dfy(8,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
11 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
12 |   match e
   |          ^

ex.dfy(12,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
12 |   match e {
   |            ^

ex.dfy(12,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
13 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(13,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
14 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
15 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(15,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
16 |     case _ => e
   |                ^

ex.dfy(16,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
17 |   }
   |    ^

ex.dfy(17,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
23 |   match e {
   |            ^

ex.dfy(23,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(24,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
24 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(24,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
24 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(24,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
25 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(25,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.

   |
25 |       // Recursive case: e is an addition.
   |                                           ^

ex.dfy(25,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      // Recursive case: e is an addition.\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize e1 and e2, then check the lemma for the optimized expressions.

   |
26 |       // Optimize e1 and e2, then check the lemma for the optimized expressions.
   |                                                                                 ^

ex.dfy(26,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize e1 and e2, then check the optimized expressions.

   |
26 |       // Optimize e1 and e2, then check the optimized expressions.
   |                                                                   ^

ex.dfy(26,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.

   |
26 |       // Optimize its sub-expressions and then apply the lemma recursively.
   |                                                                            ^

ex.dfy(26,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Recursively prove the lemma for the sub-expressions e1 and e2.

   |
26 |       // Recursively prove the lemma for the sub-expressions e1 and e2.
   |                                                                        ^

ex.dfy(26,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Optimize e1 and e2, then check the lemma for the optimized expressions.\n', '      // Optimize e1 and e2, then check the optimized expressions.\n', '      // Optimize e1 and e2, then check the lemma for the optimized expressions.\n', '      // Optimize its sub-expressions and then apply the lemma recursively.\n', '      // Recursively prove the lemma for the sub-expressions e1 and e2.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);

   |
27 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
29 |     case _ =>
   |              ^

ex.dfy(29,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.

   |
30 |       // Base case: e is not an addition.
   |                                          ^

ex.dfy(30,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: e is not an addition.\n', '      // Base case: e is not an addition.\n', '      // Base case: e is not an addition.\n', '      // Base case: e is not an addition.\n', '      // Base case: e is not an addition.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Nothing to do here.

   |
31 |       // Nothing to do here.
   |                             ^

ex.dfy(31,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Nothing to do; the lemma holds trivially.

   |
31 |       // Nothing to do; the lemma holds trivially.
   |                                                   ^

ex.dfy(31,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // In this case, the optimizer does not change e, so optimal(e) = optimal(optimize(e)).

   |
31 |       // In this case, the optimizer does not change e, so optimal(e) = optimal(optimize(e)).
   |                                                                                              ^

ex.dfy(31,93): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,

   |
31 |       // Since optimize doesn't change non-addition expressions,
   |                                                                 ^

ex.dfy(31,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since the optimizer doesn't change non-addition expressions,

   |
31 |       // Since the optimizer doesn't change non-addition expressions,
   |                                                                      ^

ex.dfy(31,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Nothing to do here.\n', '      // Nothing to do; the lemma holds trivially.\n', '      // In this case, the optimizer does not change e, so optimal(e) = optimal(optimize(e)).\n', "      // Since optimize doesn't change non-addition expressions,\n", "      // Since the optimizer doesn't change non-addition expressions,\n"]
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,
      // the result is optimal if the original expression is optimal.

   |
32 |       // the result is optimal if the original expression is optimal.
   |                                                                      ^

ex.dfy(32,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,
      // the optimality of e follows immediately.

   |
32 |       // the optimality of e follows immediately.
   |                                                  ^

ex.dfy(32,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,
      // the result of optimize(e) is the same as e, and thus optimal.

   |
32 |       // the result of optimize(e) is the same as e, and thus optimal.
   |                                                                       ^

ex.dfy(32,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,
      // the result of optimize(e) is also optimal.

   |
32 |       // the result of optimize(e) is also optimal.
   |                                                    ^

ex.dfy(32,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,
      // the resulting expression is also optimal.

   |
32 |       // the resulting expression is also optimal.
   |                                                   ^

ex.dfy(32,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // the result is optimal if the original expression is optimal.\n', '      // the optimality of e follows immediately.\n', '      // the result of optimize(e) is the same as e, and thus optimal.\n', '      // the result of optimize(e) is also optimal.\n', '      // the resulting expression is also optimal.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,
      // the result of optimize(e) is also optimal.
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      // Recursive case: e is an addition.
      // Optimize its sub-expressions and then apply the lemma recursively.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
      // Base case: e is not an addition.
      // Since optimize doesn't change non-addition expressions,
      // the result of optimize(e) is also optimal.
  }
}

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,27): Related location
  |
6 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
25 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
27 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
29 |     case _ =>
   |              ^

ex.dfy(29,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,27): Related location
  |
6 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
24 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(24,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => {\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);

   |
25 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(25,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimized expression is just e2.

   |
25 |       // The optimized expression is just e2.
   |                                              ^

ex.dfy(25,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case for optimization: optimize(Add(0, e2)) = optimize(e2)

   |
25 |       // Base case for optimization: optimize(Add(0, e2)) = optimize(e2)
   |                                                                         ^

ex.dfy(25,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2

   |
25 |       // Recursive call for e2
   |                               ^

ex.dfy(25,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      // The optimized expression is just e2.\n', '      OptimizerOptimal(e2);\n', '      // Base case for optimization: optimize(Add(0, e2)) = optimize(e2)\n', '      // Recursive call for e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }

   |
27 |     }
   |      ^

ex.dfy(27,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
28 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1

   |
29 |       // Recursive call for e1
   |                               ^

ex.dfy(29,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursive call for e1\n', '      // Recursive call for e1\n', '      // Recursive call for e1\n', '      // Recursive call for e1\n', '      // Recursive call for e1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }

   |
31 |     }
   |      ^

ex.dfy(31,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
32 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(32,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive calls for e1 and e2

   |
33 |       // Recursive calls for e1 and e2
   |                                       ^

ex.dfy(33,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2

   |
33 |       // Recursive call for e1 and e2
   |                                      ^

ex.dfy(33,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursive calls for e1 and e2\n', '      // Recursive calls for e1 and e2\n', '      // Recursive call for e1 and e2\n', '      // Recursive calls for e1 and e2\n', '      // Recursive call for e1 and e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);

   |
34 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(34,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
35 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
36 |     }
   |      ^

ex.dfy(36,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {

   |
37 |     case _ => {
   |                ^

ex.dfy(37,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()

   |
37 |     case _ => ()
   |                 ^

ex.dfy(37,16): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}

   |
37 |     case _ => {}
   |                 ^

ex.dfy(37,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n', '    case _ => ()\n', '    case _ => {}\n', '    case _ => {}\n', '    case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => ()
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => ()
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` import 'package:flutter/material.dart';

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => ()
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
```

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => ()
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Recursive call for e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive call for e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` package com.github.kristofa.brave;

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => ()
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
["``` import 'package:flutter/material.dart';\n", '```\n', '```\n', '``` package com.github.kristofa.brave;\n', '```\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(24,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => {\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => {}

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(24,46): Error: missing semicolon at end of statement
   |
25 |     case _ => {}
   |                 ^

ex.dfy(25,16): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(24,46): Error: missing semicolon at end of statement
   |
25 |     case _ =>
   |              ^

ex.dfy(25,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(24,46): Error: missing semicolon at end of statement
   |
25 |     case _ => ()
   |                 ^

ex.dfy(25,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => {}\n', '    case _ =>\n', '    case _ => ()\n', '    case _ => {}\n', '    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => {}
  }

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(24,46): Error: missing semicolon at end of statement
   |
26 |   }
   |    ^

ex.dfy(26,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => {\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)

   |
25 |       // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
   |                                                                ^

ex.dfy(25,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call

   |
25 |       // Recursive call
   |                        ^

ex.dfy(25,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, we know that the optimized expression is just e2,

   |
25 |       // In this case, we know that the optimized expression is just e2,
   |                                                                         ^

ex.dfy(25,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursive call for the optimized expression

   |
25 |       // Recursive call for the optimized expression
   |                                                     ^

ex.dfy(25,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The lemma holds because the optimizer removes additions by 0.

   |
25 |       // The lemma holds because the optimizer removes additions by 0.
   |                                                                       ^

ex.dfy(25,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)\n', '      // Recursive call\n', '      // In this case, we know that the optimized expression is just e2,\n', '      // Recursive call for the optimized expression\n', '      // The lemma holds because the optimizer removes additions by 0.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize

   |
26 |       // By definition of optimize
   |                                   ^

ex.dfy(26,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize.

   |
26 |       // By definition of optimize.
   |                                    ^

ex.dfy(26,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n', '      // By definition of optimize.\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }

   |
28 |     }
   |      ^

ex.dfy(28,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
29 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(29,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)

   |
30 |       // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
   |                                                                ^

ex.dfy(30,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize

   |
31 |       // By definition of optimize
   |                                   ^

ex.dfy(31,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n', '      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);

   |
32 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }

   |
33 |     }
   |      ^

ex.dfy(33,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
34 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(34,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))

   |
35 |       // Inductive case: optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))
   |                                                                                  ^

ex.dfy(35,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:

   |
35 |       // Inductive case:
   |                         ^

ex.dfy(35,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Inductive case: optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))\n', '      // Inductive case: optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))\n', '      // Inductive case: optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))\n', '      // Inductive case:\n', '      // Inductive case: optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))

   |
36 |       // Assume optimal(optimize(e1)) and optimal(optimize(e2))
   |                                                                ^

ex.dfy(36,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))

   |
36 |       // optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))
   |                                                                  ^

ex.dfy(36,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Assume optimal(optimize(e1)) and optimal(optimize(e2))\n', '      // Assume optimal(optimize(e1)) and optimal(optimize(e2))\n', '      // Assume optimal(optimize(e1)) and optimal(optimize(e2))\n', '      // optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))\n', '      // optimize(Add(e1, e2)) == Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Then prove optimal(optimize(Add(e1, e2)))

   |
37 |       // Then prove optimal(optimize(Add(e1, e2)))
   |                                                   ^

ex.dfy(37,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))

   |
37 |       // Need to show: optimal(optimize(Add(e1, e2)))
   |                                                      ^

ex.dfy(37,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // By definition of optimize

   |
37 |       // By definition of optimize
   |                                   ^

ex.dfy(37,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      OptimizerOptimal(e1);

   |
37 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(37,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Then prove optimal(optimize(Add(e1, e2)))\n', '      // Need to show: optimal(optimize(Add(e1, e2)))\n', '      // By definition of optimize\n', '      // By definition of optimize\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize

   |
38 |       // By definition of optimize
   |                                   ^

ex.dfy(38,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      OptimizerOptimal(e1);

   |
38 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(38,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis

   |
38 |       // By definition of optimize and the inductive hypothesis
   |                                                                ^

ex.dfy(38,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      // By definition of optimize and the inductive hypothesis\n', '      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
      OptimizerOptimal(e1);

   |
39 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(39,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }

   |
39 |     }
   |      ^

ex.dfy(39,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '    }\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {

   |
40 |     case _ => {
   |                ^

ex.dfy(40,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: if e is not an addition, then optimize(e) == e

   |
41 |       // Base case: if e is not an addition, then optimize(e) == e
   |                                                                   ^

ex.dfy(41,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition or is an addition by 0

   |
41 |       // Base case: e is not an addition or is an addition by 0
   |                                                                ^

ex.dfy(41,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition

   |
41 |       // Base case: e is not an addition
   |                                         ^

ex.dfy(41,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: if e is not an addition, optimize(e) == e

   |
41 |       // Base case: if e is not an addition, optimize(e) == e
   |                                                              ^

ex.dfy(41,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: if e is not an addition, then optimize(e) == e\n', '      // Base case: e is not an addition or is an addition by 0\n', '      // Base case: e is not an addition\n', '      // Base case: if e is not an addition, optimize(e) == e\n', '      // Base case: if e is not an addition, optimize(e) == e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition
      // Need to show: optimal(optimize(e))

   |
42 |       // Need to show: optimal(optimize(e))
   |                                            ^

ex.dfy(42,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition
      // By definition of optimal

   |
42 |       // By definition of optimal
   |                                  ^

ex.dfy(42,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition
      // By definition of optimize

   |
42 |       // By definition of optimize
   |                                   ^

ex.dfy(42,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Need to show: optimal(optimize(e))\n', '      // By definition of optimal\n', '      // Need to show: optimal(optimize(e))\n', '      // By definition of optimize\n', '      // Need to show: optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition
      // By definition of optimal
    }

   |
43 |     }
   |      ^

ex.dfy(43,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition
      // By definition of optimal
    }
  }

   |
44 |   }
   |    ^

ex.dfy(44,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) == optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) == optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // Assume optimal(optimize(e1)) and optimal(optimize(e2))
      // Need to show: optimal(optimize(Add(e1, e2)))
      // By definition of optimize and the inductive hypothesis
    }
    case _ => {
      // Base case: e is not an addition
      // By definition of optimal
    }
  }
}

ex.dfy(24,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5292,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => {\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 31
number of gen nodes: 16 (including leaves: 5)
number of back nodes: 15 (including leaves: 11)

expansion count: 25 (including failed: 10)

cache stats {'hit': 538, 'miss': 132}
calls to generate 134
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602]

Trial calls: [760, 850, 875, 755, 735, 780, 670]


Time Statistics:

  Min: 602.00 sec, Max: 653.00 sec, Average: 616.57 sec, Standard Deviation: 17.34 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 775.00 calls, Standard Deviation: 64.25 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602]

Trial calls: [760, 850, 875, 755, 735, 780, 670]


Time Statistics:

  Min: 602.00 sec, Max: 653.00 sec, Average: 616.57 sec, Standard Deviation: 17.34 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 775.00 calls, Standard Deviation: 64.25 calls

Trial  8
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = Const(i: int)\n', 'datatype Expr =\n', 'datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n', 'datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
3 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(3,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
4 |   match e
  |          ^

ex.dfy(4,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e {\n', '  match e\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
5 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(5,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n', '  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
6 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(6,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n', '  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                 ^

ex.dfy(7,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

  |
8 |   case _ => true
  |                 ^

ex.dfy(8,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n', '  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
11 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
12 |   match e
   |          ^

ex.dfy(12,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
12 |   match e {
   |            ^

ex.dfy(12,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n', '  match e\n', '  match e\n', '  match e {\n', '  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
13 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(13,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
14 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
15 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(15,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
16 |     case _ => e
   |                ^

ex.dfy(16,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
17 |   }
   |    ^

ex.dfy(17,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
23 |   match e {
   |            ^

ex.dfy(23,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
24 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(24,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
24 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(24,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(24,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
24 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(24,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
25 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(25,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
27 |     case _ =>
   |              ^

ex.dfy(27,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
28 |   }
   |    ^

ex.dfy(28,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,27): Related location
  |
6 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(24,4): Error: a postcondition could not be proved on this return path
   |
24 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(24,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(24,46): Error: missing semicolon at end of statement
   |
25 |     case _ => ()
   |                 ^

ex.dfy(25,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(24,46): Error: missing semicolon at end of statement
   |
25 |     case _ =>
   |              ^

ex.dfy(25,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n', '    case _ => ()\n', '    case _ => ()\n', '    case _ => ()\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()
  }

   |
24 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(24,46): Error: missing semicolon at end of statement
   |
26 |   }
   |   ^

ex.dfy(26,2): Error: invalid Suffix
   |
25 |     case _ => ()
   |               ^

ex.dfy(25,14): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);

   |
25 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(25,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal

   |
25 |       // Base case: Add(0, e) is not optimal
   |                                             ^

ex.dfy(25,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so just recursively optimize e2

   |
25 |       // nothing to optimize here, so just recursively optimize e2
   |                                                                   ^

ex.dfy(25,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true

   |
25 |       // nothing to prove here, the postcondition is trivially true
   |                                                                    ^

ex.dfy(25,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      // Base case: Add(0, e) is not optimal\n', '      OptimizerOptimal(e2);\n', '      // nothing to optimize here, so just recursively optimize e2\n', '      // nothing to prove here, the postcondition is trivially true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }

   |
26 |     }
   |      ^

ex.dfy(26,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {

   |
27 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(27,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true

   |
28 |       // nothing to prove here, the postcondition is trivially true
   |                                                                    ^

ex.dfy(28,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // nothing to prove here, the postcondition is trivially true\n', '      // nothing to prove here, the postcondition is trivially true\n', '      // nothing to prove here, the postcondition is trivially true\n', '      // nothing to prove here, the postcondition is trivially true\n', '      // nothing to prove here, the postcondition is trivially true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }

   |
29 |     }
   |      ^

ex.dfy(29,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {

   |
30 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursively prove the lemma for the sub-expressions

   |
31 |       // recursively prove the lemma for the sub-expressions
   |                                                             ^

ex.dfy(31,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions

   |
31 |       // recursive call for the sub-expressions
   |                                                ^

ex.dfy(31,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // recursively prove the lemma for the sub-expressions\n', '      OptimizerOptimal(e1);\n', '      // recursively prove the lemma for the sub-expressions\n', '      // recursive call for the sub-expressions\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);

   |
32 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
33 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {

   |
35 |     case _ => {
   |                ^

ex.dfy(35,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // nothing to prove here, the postcondition is trivially true

   |
36 |       // nothing to prove here, the postcondition is trivially true
   |                                                                    ^

ex.dfy(36,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case, the postcondition is trivially true

   |
36 |       // base case, the postcondition is trivially true
   |                                                        ^

ex.dfy(36,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // nothing to prove here, the postcondition is trivially true\n', '      // base case, the postcondition is trivially true\n', '      // nothing to prove here, the postcondition is trivially true\n', '      // nothing to prove here, the postcondition is trivially true\n', '      // nothing to prove here, the postcondition is trivially true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case, the postcondition is trivially true
    }

   |
37 |     }
   |      ^

ex.dfy(37,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case, the postcondition is trivially true
    }
  }

   |
38 |   }
   |    ^

ex.dfy(38,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, Const(0)) => {
      // nothing to prove here, the postcondition is trivially true
    }
    case Add(e1, e2) => {
      // recursive call for the sub-expressions
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // base case, the postcondition is trivially true
    }
  }
}

ex.dfy(24,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5299,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
25 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
27 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
29 |     case _ =>
   |              ^

ex.dfy(29,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,27): Related location
  |
6 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => {\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursively call the lemma on the optimized sub-expression.

   |
25 |       // Recursively call the lemma on the optimized sub-expression.
   |                                                                     ^

ex.dfy(25,68): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case

   |
25 |       // In this case, optimize(e) = optimize(e2) because of the match case
   |                                                                            ^

ex.dfy(25,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e2) is not optimal.

   |
25 |       // Base case: Add(0, e2) is not optimal.
   |                                               ^

ex.dfy(25,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursively call the lemma on the optimized sub-expression.\n', '      // In this case, optimize(e) = optimize(e2) because of the match case\n', '      OptimizerOptimal(e2);\n', '      // Base case: Add(0, e2) is not optimal.\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      // So we just need to recursively call the lemma on e2

   |
26 |       // So we just need to recursively call the lemma on e2
   |                                                             ^

ex.dfy(26,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call

   |
26 |       OptimizerOptimal(e2); // recursive call
   |                                              ^

ex.dfy(26,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // So we just need to recursively call the lemma on e2\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2); // recursive call\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }

   |
27 |     }
   |      ^

ex.dfy(27,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {

   |
28 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case

   |
29 |       // In this case, optimize(e) = optimize(e1) because of the match case
   |                                                                            ^

ex.dfy(29,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, optimize(e) = optimize(e1) because of the match case\n', '      // In this case, optimize(e) = optimize(e1) because of the match case\n', '      // In this case, optimize(e) = optimize(e1) because of the match case\n', '      // In this case, optimize(e) = optimize(e1) because of the match case\n', '      // In this case, optimize(e) = optimize(e1) because of the match case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call

   |
30 |       OptimizerOptimal(e1); // recursive call
   |                                              ^

ex.dfy(30,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }

   |
31 |     }
   |      ^

ex.dfy(31,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {

   |
32 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(32,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case

   |
33 |       // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
   |                                                                                               ^

ex.dfy(33,94): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case\n', '      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case\n', '      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case\n', '      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case\n', '      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call

   |
34 |       OptimizerOptimal(e1); // recursive call
   |                                              ^

ex.dfy(34,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n', '      OptimizerOptimal(e1); // recursive call\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call

   |
35 |       OptimizerOptimal(e2); // recursive call
   |                                              ^

ex.dfy(35,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2); // recursive call\n', '      OptimizerOptimal(e2); // recursive call\n', '      OptimizerOptimal(e2); // recursive call\n', '      OptimizerOptimal(e2); // recursive call\n', '      OptimizerOptimal(e2); // recursive call\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }

   |
36 |     }
   |      ^

ex.dfy(36,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case: nothing to prove

   |
37 |     case _ => () // base case: nothing to prove
   |                                                ^

ex.dfy(37,47): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case

   |
37 |     case _ => () // base case
   |                              ^

ex.dfy(37,29): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => {} // base case, do nothing

   |
37 |     case _ => {} // base case, do nothing
   |                                          ^

ex.dfy(37,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => // nothing to prove, because e is not an addition or addition by 0

   |
37 |     case _ => // nothing to prove, because e is not an addition or addition by 0
   |                                                                                 ^

ex.dfy(37,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // nothing to prove for other cases

   |
37 |     case _ => () // nothing to prove for other cases
   |                                                     ^

ex.dfy(37,52): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => () // base case: nothing to prove\n', '    case _ => () // base case\n', '    case _ => {} // base case, do nothing\n', '    case _ => // nothing to prove, because e is not an addition or addition by 0\n', '    case _ => () // nothing to prove for other cases\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case
  }

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => () // base case
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case
  }
}

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => () // base case
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case
  }
}
``` package com.example.android.miwok;

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => () // base case
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case
  }
}
``` package com.jayfella.devkit.properties;

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => () // base case
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case
  }
}
``` import {

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => () // base case
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match case
      OptimizerOptimal(e2); // recursive call
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match case
      OptimizerOptimal(e1); // recursive call
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)) because of the match case
      OptimizerOptimal(e1); // recursive call
      OptimizerOptimal(e2); // recursive call
    }
    case _ => () // base case
  }
}
```

   |
38 |   }
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |     case _ => () // base case
   |               ^

ex.dfy(37,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['``` package com.example.android.miwok;\n', '``` package com.jayfella.devkit.properties;\n', '``` import {\n', '```\n', '```\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => {\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)

   |
25 |       // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
   |                                                               ^

ex.dfy(25,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The lemma holds because the optimization removes the addition by 0.

   |
25 |       // The lemma holds because the optimization removes the addition by 0.
   |                                                                             ^

ex.dfy(25,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, the optimization removes the addition by 0,

   |
25 |       // In this case, the optimization removes the addition by 0,
   |                                                                   ^

ex.dfy(25,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)\n', '      // The lemma holds because the optimization removes the addition by 0.\n', '      OptimizerOptimal(e2);\n', '      // In this case, the optimization removes the addition by 0,\n', '      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize

   |
26 |       // By definition of optimize
   |                                   ^

ex.dfy(26,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize

   |
26 |       // By def. of optimize
   |                             ^

ex.dfy(26,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      // By definition of optimize\n', '      // By def. of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }

   |
28 |     }
   |      ^

ex.dfy(28,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
29 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(29,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)

   |
30 |       // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
   |                                                               ^

ex.dfy(30,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n', '      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize

   |
31 |       // By def. of optimize
   |                             ^

ex.dfy(31,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By def. of optimize\n', '      // By def. of optimize\n', '      // By def. of optimize\n', '      // By def. of optimize\n', '      // By def. of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);

   |
32 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }

   |
33 |     }
   |      ^

ex.dfy(33,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
34 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(34,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:

   |
35 |       // Inductive case:
   |                         ^

ex.dfy(35,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))

   |
35 |       // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
   |                                                                                 ^

ex.dfy(35,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Inductive case:\n', '      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // Inductive case:\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))

   |
36 |       // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
   |                                                                 ^

ex.dfy(36,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))

   |
36 |       // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
   |                                                                                   ^

ex.dfy(36,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))\n', '      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n', '      // optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize

   |
37 |       // By def. of optimize
   |                             ^

ex.dfy(37,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By def. of optimize\n', '      // By def. of optimize\n', '      // By def. of optimize\n', '      // By def. of optimize\n', '      // By def. of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);

   |
38 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(38,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
39 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(39,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
40 |     }
   |      ^

ex.dfy(40,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {

   |
41 |     case _ => {
   |                ^

ex.dfy(41,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()

   |
41 |     case _ => ()
   |                 ^

ex.dfy(41,16): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // Cases for Const and Var: nothing to prove.

   |
41 |     case _ => () // Cases for Const and Var: nothing to prove.
   |                                                               ^

ex.dfy(41,62): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n', '    case _ => ()\n', '    case _ => () // Cases for Const and Var: nothing to prove.\n', '    case _ => {\n', '    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // Cases for Const and Var: nothing to prove.
  }

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => () // Cases for Const and Var: nothing to prove.
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // Cases for Const and Var: nothing to prove.
  }
}

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => () // Cases for Const and Var: nothing to prove.
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // Cases for Const and Var: nothing to prove.
  }
}
``` package org.apache.ignite.internal.processors.cache.distributed.dht;

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => () // Cases for Const and Var: nothing to prove.
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // Cases for Const and Var: nothing to prove.
  }
}
``` ﻿using System;

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => () // Cases for Const and Var: nothing to prove.
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // Cases for Const and Var: nothing to prove.
  }
}
```

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => () // Cases for Const and Var: nothing to prove.
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By def. of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By def. of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case:
      // optimal(optimize(Add(e1, e2))) = optimal(Add(optimize(e1), optimize(e2)))
      // By def. of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // Cases for Const and Var: nothing to prove.
  }
}
``` 

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => () // Cases for Const and Var: nothing to prove.
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['``` package org.apache.ignite.internal.processors.cache.distributed.dht;\n', '``` \ufeffusing System;\n', '```\n', '```\n', '``` \n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 4)
number of back nodes: 14 (including leaves: 11)

expansion count: 23 (including failed: 9)

cache stats {'hit': 544, 'miss': 131}
calls to generate 135
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602, 601]

Trial calls: [760, 850, 875, 755, 735, 780, 670, 675]


Time Statistics:

  Min: 601.00 sec, Max: 653.00 sec, Average: 614.62 sec, Standard Deviation: 17.02 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 762.50 calls, Standard Deviation: 68.60 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602, 601]

Trial calls: [760, 850, 875, 755, 735, 780, 670, 675]


Time Statistics:

  Min: 601.00 sec, Max: 653.00 sec, Average: 614.62 sec, Standard Deviation: 17.02 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 762.50 calls, Standard Deviation: 68.60 calls

Trial  9
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr =\n', 'datatype Expr =\n', 'datatype Expr =\n', 'datatype Expr = \n', 'datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(n: int)

SCORE
1.0
['  | Const(val: int)\n', '  | Const(v: int)\n', '  | Const(i: int)\n', '  | Const(n: int)\n', '  | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n', '  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n', '  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
15 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
16 |   match e {
   |            ^

ex.dfy(16,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
17 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
18 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
19 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(19,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
21 |   }
   |    ^

ex.dfy(21,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(29,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(v: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 47
number of gen nodes: 24 (including leaves: 7)
number of back nodes: 23 (including leaves: 17)

expansion count: 38 (including failed: 15)

cache stats {'hit': 832, 'miss': 43}
calls to generate 175
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602, 601, 629]

Trial calls: [760, 850, 875, 755, 735, 780, 670, 675, 875]


Time Statistics:

  Min: 601.00 sec, Max: 653.00 sec, Average: 616.22 sec, Standard Deviation: 16.67 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 775.00 calls, Standard Deviation: 73.71 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602, 601, 629]

Trial calls: [760, 850, 875, 755, 735, 780, 670, 675, 875]


Time Statistics:

  Min: 601.00 sec, Max: 653.00 sec, Average: 616.22 sec, Standard Deviation: 16.67 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 775.00 calls, Standard Deviation: 73.71 calls

Trial  10
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(x: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(val: int)\n', 'datatype Expr = Const(val: int)\n', 'datatype Expr =\n', 'datatype Expr =\n', 'datatype Expr = Const(i: int) | Var(x: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n', '              | Var(name: string)\n', '             | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n', '             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
5 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(5,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n', 'predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
7 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(7,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n', '    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
8 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n', '    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
9 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                   ^

ex.dfy(9,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n', '    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
10 |     case _ => true
   |                   ^

ex.dfy(10,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n', '    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
11 |   }
   |    ^

ex.dfy(11,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n', 'function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n', '    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n', '    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n', '    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n', '    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n', '\n', '\n', '\n', '\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n', '{\n', '{\n', '{\n', '{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
26 |   match e {
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(27,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(27,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n', '}\n', '}\n', '}\n', '}\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
27 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(27,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => {\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Recursively call the lemma on the optimized expression

   |
28 |       // Recursively call the lemma on the optimized expression
   |                                                                ^

ex.dfy(28,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case

   |
28 |       // Base case
   |                   ^

ex.dfy(28,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we use the lemma recursively on the optimized sub-expression.

   |
28 |       // Here, we use the lemma recursively on the optimized sub-expression.
   |                                                                             ^

ex.dfy(28,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the

   |
28 |       // Here, we're optimizing an expression of the form (0 + e2). Since the
   |                                                                              ^

ex.dfy(28,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursively call the lemma on the optimized expression\n', '      // Base case\n', '      // Here, we use the lemma recursively on the optimized sub-expression.\n', '      OptimizerOptimal(e2);\n', "      // Here, we're optimizing an expression of the form (0 + e2). Since the\n"]
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first operand is 0, we know that the optimized expression is just e2.

   |
29 |       // first operand is 0, we know that the optimized expression is just e2.
   |                                                                               ^

ex.dfy(29,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply

   |
29 |       // first argument to addition is 0, we can optimize this by simply
   |                                                                         ^

ex.dfy(29,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // optimization removes additions by 0, this case is equivalent to optimizing e2.

   |
29 |       // optimization removes additions by 0, this case is equivalent to optimizing e2.
   |                                                                                        ^

ex.dfy(29,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // optimization is to eliminate additions by 0, the optimized expression is

   |
29 |       // optimization is to eliminate additions by 0, the optimized expression is
   |                                                                                  ^

ex.dfy(29,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first operand is 0, the optimized expression is just e2.

   |
29 |       // first operand is 0, the optimized expression is just e2.
   |                                                                  ^

ex.dfy(29,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // first operand is 0, we know that the optimized expression is just e2.\n', '      // first argument to addition is 0, we can optimize this by simply\n', '      // optimization removes additions by 0, this case is equivalent to optimizing e2.\n', '      // optimization is to eliminate additions by 0, the optimized expression is\n', '      // first operand is 0, the optimized expression is just e2.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // optimizing e2.

   |
30 |       // optimizing e2.
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.

   |
30 |       // returning e2.
   |                       ^

ex.dfy(30,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning the optimized form of e2.

   |
30 |       // returning the optimized form of e2.
   |                                             ^

ex.dfy(30,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // optimizing e2.\n', '      // returning e2.\n', '      // returning the optimized form of e2.\n', '      // optimizing e2.\n', '      // returning e2.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //

   |
31 |       //
   |         ^

ex.dfy(31,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      //\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // We then recursively call the lemma on e2.

   |
32 |       // We then recursively call the lemma on e2.
   |                                                   ^

ex.dfy(32,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // By the lemma postcondition, we know that the optimized expression is

   |
32 |       // By the lemma postcondition, we know that the optimized expression is
   |                                                                              ^

ex.dfy(32,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // By the lemma's precondition, optimal(optimize(e2)) holds. Since we've

   |
32 |       // By the lemma's precondition, optimal(optimize(e2)) holds. Since we've
   |                                                                               ^

ex.dfy(32,78): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2

   |
32 |       // The lemma holds because the optimized expression is now e2, and e2
   |                                                                            ^

ex.dfy(32,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // By the inductive hypothesis, we know that optimize(e2) is optimal.

   |
32 |       // By the inductive hypothesis, we know that optimize(e2) is optimal.
   |                                                                            ^

ex.dfy(32,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // We then recursively call the lemma on e2.\n', '      // By the lemma postcondition, we know that the optimized expression is\n', "      // By the lemma's precondition, optimal(optimize(e2)) holds. Since we've\n", '      // The lemma holds because the optimized expression is now e2, and e2\n', '      // By the inductive hypothesis, we know that optimize(e2) is optimal.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // might still contain additions by 0, but we've removed one.

   |
33 |       // might still contain additions by 0, but we've removed one.
   |                                                                    ^

ex.dfy(33,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is also optimal by the recursive call to OptimizerOptimal.

   |
33 |       // is also optimal by the recursive call to OptimizerOptimal.
   |                                                                    ^

ex.dfy(33,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression

   |
33 |       // is the second argument to addition, so the optimized expression
   |                                                                         ^

ex.dfy(33,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // doesn't have any addition by 0.

   |
33 |       // doesn't have any addition by 0.
   |                                         ^

ex.dfy(33,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // might not have any additions by 0 (depending on its structure).

   |
33 |       // might not have any additions by 0 (depending on its structure).
   |                                                                         ^

ex.dfy(33,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      // might still contain additions by 0, but we've removed one.\n", '      // is also optimal by the recursive call to OptimizerOptimal.\n', '      // is the second argument to addition, so the optimized expression\n', "      // doesn't have any addition by 0.\n", '      // might not have any additions by 0 (depending on its structure).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // still has no additions by 0.

   |
34 |       // still has no additions by 0.
   |                                      ^

ex.dfy(34,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the predicate `optimal` if and only if e2 does.

   |
34 |       // satisfies the predicate `optimal` if and only if e2 does.
   |                                                                   ^

ex.dfy(34,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // doesn't have any additions by 0.

   |
34 |       // doesn't have any additions by 0.
   |                                          ^

ex.dfy(34,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.

   |
34 |       // satisfies the conditions for `optimal`.
   |                                                 ^

ex.dfy(34,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // still has no additions by 0.\n', '      // satisfies the predicate `optimal` if and only if e2 does.\n', "      // doesn't have any additions by 0.\n", "      // doesn't have any additions by 0.\n", '      // satisfies the conditions for `optimal`.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }

   |
35 |     }
   |      ^

ex.dfy(35,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {

   |
36 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(36,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n', '    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) returns e1.

   |
37 |       // Similarly, optimizing an expression of the form (e1 + 0) returns e1.
   |                                                                              ^

ex.dfy(37,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similar to the previous case, we're optimizing an expression of the

   |
37 |       // Similar to the previous case, we're optimizing an expression of the
   |                                                                             ^

ex.dfy(37,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Here, we're optimizing an expression of the form (e1 + 0). Since the

   |
37 |       // Here, we're optimizing an expression of the form (e1 + 0). Since the
   |                                                                              ^

ex.dfy(37,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in

   |
37 |       // Similarly, optimizing an expression of the form (e1 + 0) results in
   |                                                                             ^

ex.dfy(37,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, if the second argument to addition is 0, we can optimize

   |
37 |       // Similarly, if the second argument to addition is 0, we can optimize
   |                                                                             ^

ex.dfy(37,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Similarly, optimizing an expression of the form (e1 + 0) returns e1.\n', "      // Similar to the previous case, we're optimizing an expression of the\n", "      // Here, we're optimizing an expression of the form (e1 + 0). Since the\n", '      // Similarly, optimizing an expression of the form (e1 + 0) results in\n', '      // Similarly, if the second argument to addition is 0, we can optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the

   |
38 |       // simply returning e1, and the optimized expression satisfies the
   |                                                                         ^

ex.dfy(38,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1. The lemma holds for similar reasons.

   |
38 |       // simply returning e1. The lemma holds for similar reasons.
   |                                                                   ^

ex.dfy(38,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the lemma holds for the same reasons as the

   |
38 |       // simply returning e1, and the lemma holds for the same reasons as the
   |                                                                              ^

ex.dfy(38,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // e1, and the optimized expression satisfies the conditions for `optimal`.

   |
38 |       // e1, and the optimized expression satisfies the conditions for `optimal`.
   |                                                                                  ^

ex.dfy(38,81): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // simply returning e1, and the optimized expression satisfies the\n', '      // simply returning e1. The lemma holds for similar reasons.\n', '      // simply returning e1, and the optimized expression satisfies the\n', '      // simply returning e1, and the lemma holds for the same reasons as the\n', '      // e1, and the optimized expression satisfies the conditions for `optimal`.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.

   |
39 |       // conditions for `optimal`.
   |                                   ^

ex.dfy(39,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // conditions for `optimal`.\n', '      // conditions for `optimal`.\n', '      // conditions for `optimal`.\n', '      // conditions for `optimal`.\n', '      // conditions for `optimal`.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }

   |
40 |     }
   |      ^

ex.dfy(40,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {

   |
41 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(41,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n', '    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // Recursively apply the lemma to the sub-expressions e1 and e2.

   |
42 |       // Recursively apply the lemma to the sub-expressions e1 and e2.
   |                                                                       ^

ex.dfy(42,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // When optimizing an expression of the form (e1 + e2), we recursively

   |
42 |       // When optimizing an expression of the form (e1 + e2), we recursively
   |                                                                             ^

ex.dfy(42,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // For an expression of the form (e1 + e2), we recursively optimize

   |
42 |       // For an expression of the form (e1 + e2), we recursively optimize
   |                                                                          ^

ex.dfy(42,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize

   |
42 |       // If the expression is already in the form (e1 + e2), we optimize
   |                                                                         ^

ex.dfy(42,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is a binary addition, we optimize each sub-expression

   |
42 |       // If the expression is a binary addition, we optimize each sub-expression
   |                                                                                 ^

ex.dfy(42,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursively apply the lemma to the sub-expressions e1 and e2.\n', '      // When optimizing an expression of the form (e1 + e2), we recursively\n', '      // For an expression of the form (e1 + e2), we recursively optimize\n', '      // If the expression is already in the form (e1 + e2), we optimize\n', '      // If the expression is a binary addition, we optimize each sub-expression\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // each sub-expression recursively.

   |
43 |       // each sub-expression recursively.
   |                                          ^

ex.dfy(43,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions

   |
43 |       // both sub-expressions and then check if the optimized sub-expressions
   |                                                                              ^

ex.dfy(43,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // each sub-expression and then check the `optimal` predicate for the

   |
43 |       // each sub-expression and then check the `optimal` predicate for the
   |                                                                            ^

ex.dfy(43,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // recursively by optimizing both sub-expressions e1 and e2.

   |
43 |       // recursively by optimizing both sub-expressions e1 and e2.
   |                                                                   ^

ex.dfy(43,66): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both e1 and e2 recursively and then reconstruct the addition.

   |
43 |       // both e1 and e2 recursively and then reconstruct the addition.
   |                                                                       ^

ex.dfy(43,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // each sub-expression recursively.\n', '      // both sub-expressions and then check if the optimized sub-expressions\n', '      // each sub-expression and then check the `optimal` predicate for the\n', '      // recursively by optimizing both sub-expressions e1 and e2.\n', '      // both e1 and e2 recursively and then reconstruct the addition.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.

   |
44 |       // satisfy the conditions for `optimal`.
   |                                               ^

ex.dfy(44,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // satisfy the conditions for `optimal`.\n', '      // satisfy the conditions for `optimal`.\n', '      // satisfy the conditions for `optimal`.\n', '      // satisfy the conditions for `optimal`.\n', '      // satisfy the conditions for `optimal`.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      OptimizerOptimal(e1);

   |
45 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(45,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //

   |
45 |       //
   |         ^

ex.dfy(45,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      //\n', '      //\n', '      //\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // The lemma holds because the optimized expression is now (optimize(e1) + optimize(e2)),

   |
46 |       // The lemma holds because the optimized expression is now (optimize(e1) + optimize(e2)),
   |                                                                                                ^

ex.dfy(46,95): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // We know that the optimized sub-expressions satisfy the conditions

   |
46 |       // We know that the optimized sub-expressions satisfy the conditions
   |                                                                           ^

ex.dfy(46,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition

   |
46 |       // This is because `optimal` is defined recursively for addition
   |                                                                       ^

ex.dfy(46,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // Since we recursively call the lemma on the sub-expressions, we know

   |
46 |       // Since we recursively call the lemma on the sub-expressions, we know
   |                                                                             ^

ex.dfy(46,76): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // The lemma holds because the optimized expression is now (optimize(e1) +

   |
46 |       // The lemma holds because the optimized expression is now (optimize(e1) +
   |                                                                                 ^

ex.dfy(46,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The lemma holds because the optimized expression is now (optimize(e1) + optimize(e2)),\n', '      // We know that the optimized sub-expressions satisfy the conditions\n', '      // This is because `optimal` is defined recursively for addition\n', '      // Since we recursively call the lemma on the sub-expressions, we know\n', '      // The lemma holds because the optimized expression is now (optimize(e1) +\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.

   |
47 |       // expressions.
   |                      ^

ex.dfy(47,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions, so we need to check if the optimized sub-expressions

   |
47 |       // expressions, so we need to check if the optimized sub-expressions
   |                                                                           ^

ex.dfy(47,74): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // expressions.\n', '      // expressions, so we need to check if the optimized sub-expressions\n', '      // expressions.\n', '      // expressions.\n', '      // expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);

   |
48 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(48,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
49 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(49,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
50 |     }
   |      ^

ex.dfy(50,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n', '    }\n', '    }\n', '    }\n', '    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {

   |
51 |     case _ => {
   |                ^

ex.dfy(51,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n', '    case _ => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // If the expression is a constant or variable, it's already in its

   |
52 |       // If the expression is a constant or variable, it's already in its
   |                                                                          ^

ex.dfy(52,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // If the expression is a constant or variable, it doesn't have any

   |
52 |       // If the expression is a constant or variable, it doesn't have any
   |                                                                          ^

ex.dfy(52,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // If the expression is a constant or a variable, it doesn't have

   |
52 |       // If the expression is a constant or a variable, it doesn't have
   |                                                                        ^

ex.dfy(52,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // For all other expression forms, the optimized expression is the

   |
52 |       // For all other expression forms, the optimized expression is the
   |                                                                         ^

ex.dfy(52,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // If the expression is a constant or a variable, it's already in its

   |
52 |       // If the expression is a constant or a variable, it's already in its
   |                                                                            ^

ex.dfy(52,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      // If the expression is a constant or variable, it's already in its\n", "      // If the expression is a constant or variable, it doesn't have any\n", "      // If the expression is a constant or a variable, it doesn't have\n", '      // For all other expression forms, the optimized expression is the\n', "      // If the expression is a constant or a variable, it's already in its\n"]
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // If the expression is a constant or variable, it doesn't have any
      // additions by 0, so the optimized expression satisfies the conditions

   |
53 |       // additions by 0, so the optimized expression satisfies the conditions
   |                                                                              ^

ex.dfy(53,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // If the expression is a constant or variable, it doesn't have any
      // additions by 0, so it must satisfy the conditions for `optimal`.

   |
53 |       // additions by 0, so it must satisfy the conditions for `optimal`.
   |                                                                          ^

ex.dfy(53,73): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here, we're optimizing an expression of the form (0 + e2). Since the
      // first argument to addition is 0, we can optimize this by simply
      // returning e2.
      //
      // The lemma holds because the optimized expression is now e2, and e2
      // is the second argument to addition, so the optimized expression
      // satisfies the conditions for `optimal`.
    }
    case Add(e1, Const(0)) => {
      // Similarly, optimizing an expression of the form (e1 + 0) results in
      // simply returning e1, and the optimized expression satisfies the
      // conditions for `optimal`.
    }
    case Add(e1, e2) => {
      // If the expression is already in the form (e1 + e2), we optimize
      // both sub-expressions and then check if the optimized sub-expressions
      // satisfy the conditions for `optimal`.
      //
      // This is because `optimal` is defined recursively for addition
      // expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // If the expression is a constant or variable, it doesn't have any
      // addition by 0, so it satisfies the conditions for `optimal`.

   |
53 |       // addition by 0, so it satisfies the conditions for `optimal`.
   |                                                                      ^

ex.dfy(53,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // additions by 0, so the optimized expression satisfies the conditions\n', '      // additions by 0, so the optimized expression satisfies the conditions\n', '      // additions by 0, so it must satisfy the conditions for `optimal`.\n', '      // additions by 0, so the optimized expression satisfies the conditions\n', '      // addition by 0, so it satisfies the conditions for `optimal`.\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => {\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) => \n', '    case Add(e1, e2) =>\n']
['\n', '\n', '\n', '\n', '\n']
['lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n', 'lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n', '    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n', '    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
28 |     case _ => ()
   |                 ^

ex.dfy(28,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => {}

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
28 |     case _ => {}
   |                 ^

ex.dfy(28,16): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n', '    case _ => {}\n', '    case _ =>\n', '    case _ => ()\n', '    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(val: int)
             | Var(name: string)
             | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()
  }

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
29 |   }
   |   ^

ex.dfy(29,2): Error: invalid Suffix
   |
28 |     case _ => ()
   |               ^

ex.dfy(28,14): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n', '  ensures optimal(optimize(e))\n']
['{\n', '{\n', '{\n', '{\n', '{\n']
['  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n', '  match e {\n']
['    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(Const(0), e2) =>\n', '    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n', '    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n', '    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n', '      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n', '      OptimizerOptimal(e2);\n']
['    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n', '    case _ =>\n']
['  }\n', '  }\n', '  }\n', '  }\n', '  }\n']
['}\n', '}\n', '}\n', '}\n', '}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 37
number of gen nodes: 19 (including leaves: 6)
number of back nodes: 18 (including leaves: 13)

expansion count: 30 (including failed: 12)

cache stats {'hit': 567, 'miss': 128}
calls to generate 139
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602, 601, 629, 627]

Trial calls: [760, 850, 875, 755, 735, 780, 670, 675, 875, 695]


Time Statistics:

  Min: 601.00 sec, Max: 653.00 sec, Average: 617.30 sec, Standard Deviation: 16.14 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 767.00 calls, Standard Deviation: 73.93 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run_diversity.py for 10 trials

Trial times: [610, 616, 629, 603, 653, 603, 602, 601, 629, 627]

Trial calls: [760, 850, 875, 755, 735, 780, 670, 675, 875, 695]


Time Statistics:

  Min: 601.00 sec, Max: 653.00 sec, Average: 617.30 sec, Standard Deviation: 16.14 sec

Call Statistics:

  Min: 670 calls, Max: 875 calls, Average: 767.00 calls, Standard Deviation: 73.93 calls

To complete all experiments, 103 minutes and 38 seconds elapsed.


