

========
Experiment configuration: python run.py --problem_name problem_bst 


[2024-01-03 07:07:41,463] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)


========
Experiment configuration: python run.py --problem_name problem_bst 


[2024-01-03 07:08:33,431] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Define the ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).

SCORE
1.0
['// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&

   |
10 |     value >= min && value < max &&
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
12 |     IsBST(right, value, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.

SCORE
1.0
['// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
19 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(19,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tValue, right) =>

   |
20 |   case Node(left, tValue, right) =>
   |                                    ^

ex.dfy(20,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tValue, right) =>
    if value < tValue {

   |
21 |     if value < tValue {
   |                       ^

ex.dfy(21,22): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tValue, right) =>
    if value < tValue {
      Node(Insert(left, value), tValue, right)

   |
21 |     if value < tValue {
   |                       ^

ex.dfy(21,22): Error: then expected
   |
22 |       Node(Insert(left, value), tValue, right)
   |                                               ^

ex.dfy(22,46): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), tValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tValue, right) =>
    if value < tValue {
      Node(Insert(left, value), tValue, right)
    } else if value > tValue {

   |
21 |     if value < tValue {
   |                       ^

ex.dfy(21,22): Error: then expected
   |
23 |     } else if value > tValue {
   |                              ^

ex.dfy(23,29): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > tValue {\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then

   |
18 |   if t == Empty then
   |                     ^

ex.dfy(18,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)

   |
19 |     Node(Empty, value, Empty)
   |                              ^

ex.dfy(19,29): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else

   |
20 |   else
   |       ^

ex.dfy(20,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t

   |
21 |     match t
   |            ^

ex.dfy(21,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>

   |
22 |     case Node(left, tValue, right) =>
   |                                      ^

ex.dfy(22,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, tValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then

   |
23 |       if value < tValue then
   |                             ^

ex.dfy(23,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      if value < tValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)

   |
24 |         Node(Insert(left, value), tValue, right)
   |                                                 ^

ex.dfy(24,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), tValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then

   |
25 |       else if value > tValue then
   |                                  ^

ex.dfy(25,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > tValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))

   |
26 |         Node(left, tValue, Insert(right, value))
   |                                                 ^

ex.dfy(26,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['        Node(left, tValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else

   |
27 |       else
   |           ^

ex.dfy(27,10): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t

   |
28 |         t
   |          ^

ex.dfy(28,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.

SCORE
1.0
['// (4) Write a predicate that checks whether a given tree contains a given element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{

   |
33 | {
   |  ^

ex.dfy(33,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t

   |
34 |   match t
   |          ^

ex.dfy(34,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false

   |
35 |   case Empty => false
   |                      ^

ex.dfy(35,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>

   |
36 |   case Node(left, tValue, right) =>
   |                                    ^

ex.dfy(36,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)

   |
37 |     if value < tValue then Contains(left, value)
   |                                                 ^

ex.dfy(37,48): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tValue then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)

   |
38 |     else if value > tValue then Contains(right, value)
   |                                                       ^

ex.dfy(38,54): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > tValue then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true

   |
39 |     else true
   |              ^

ex.dfy(39,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).

SCORE
1.0
['// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
46 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(46,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  if t == Empty then

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  if t == Empty then
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty), and value is in this tree.

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: Insert(Empty, value) = Node(Empty, value, Empty), and value is in this tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  if t == Empty then
    // Base case: Insert(Empty, value) = Node(Empty, value, Empty), and value is in this tree.
  else

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  else\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.

   |
46 |   // Proof by structural induction on the tree `t`.
   |                                                    ^

ex.dfy(46,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree `t`.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t

   |
47 |   match t
   |          ^

ex.dfy(47,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>

   |
48 |   case Empty =>
   |                ^

ex.dfy(48,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.

   |
49 |     // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
   |                                                                                             ^

ex.dfy(49,92): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
    assert Contains(Node(Empty, value, Empty), value);

   |
50 |     assert Contains(Node(Empty, value, Empty), value);
   |                                                       ^

ex.dfy(50,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Empty, value, Empty), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, tValue, right) =>

   |
51 |   case Node(left, tValue, right) =>
   |                                    ^

ex.dfy(51,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, tValue, right) =>
    // Inductive step: If `value` is less than `tValue`, then `value` must be in `left`.

   |
52 |     // Inductive step: If `value` is less than `tValue`, then `value` must be in `left`.
   |                                                                                         ^

ex.dfy(52,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive step: If `value` is less than `tValue`, then `value` must be in `left`.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, tValue, right) =>
    // Inductive step: If `value` is less than `tValue`, then `value` must be in `left`.
    // If `value` is greater than or equal to `tValue`, then `value` must be in `right`.

   |
53 |     // If `value` is greater than or equal to `tValue`, then `value` must be in `right`.
   |                                                                                         ^

ex.dfy(53,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // If `value` is greater than or equal to `tValue`, then `value` must be in `right`.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, tValue, right) =>
    // Inductive step: If `value` is less than `tValue`, then `value` must be in `left`.
    // If `value` is greater than or equal to `tValue`, then `value` must be in `right`.
    if value < tValue then

   |
54 |     if value < tValue then
   |                       ^

ex.dfy(54,22): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, tValue, right) =>
    // Inductive step: If `value` is less than `tValue`, then `value` must be in `left`.
    // If `value` is greater than or equal to `tValue`, then `value` must be in `right`.
    if value < tValue then
      assert Contains(Insert(left, value), value);

   |
54 |     if value < tValue then
   |                       ^

ex.dfy(54,22): Error: lbrace expected
   |
55 |       assert Contains(Insert(left, value), value);
   |                                                   ^

ex.dfy(55,50): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(Insert(left, value), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree `t`.
  match t
  case Empty =>
    // Base case: If `t` is empty, then `Insert(t, value)` is a new node containing `value`.
    assert Contains(Node(Empty, value, Empty), value);
  case Node(left, tValue, right) =>
    // Inductive step: If `value` is less than `tValue`, then `value` must be in `left`.
    // If `value` is greater than or equal to `tValue`, then `value` must be in `right`.
    if value < tValue then
      assert Contains(Insert(left, value), value);
    else

   |
54 |     if value < tValue then
   |                       ^

ex.dfy(54,22): Error: lbrace expected
   |
56 |     else
   |     ^

ex.dfy(56,4): Error: this symbol not expected in CaseStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['    else\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof is by induction on the structure of the tree.

   |
46 |   // Proof is by induction on the structure of the tree.
   |                                                         ^

ex.dfy(46,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by induction on the structure of the tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof is by induction on the structure of the tree.
  if t == Empty then

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof is by induction on the structure of the tree.
  if t == Empty then
    // Base case: If the tree is empty, then the result of inserting value is a new node containing value.

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: If the tree is empty, then the result of inserting value is a new node containing value.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof is by induction on the structure of the tree.
  if t == Empty then
    // Base case: If the tree is empty, then the result of inserting value is a new node containing value.
    assert Insert(Empty, value) == Node(Empty, value, Empty);

   |
47 |   if t == Empty then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert Insert(Empty, value) == Node(Empty, value, Empty);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.

   |
46 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(46,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.

SCORE
1.0
['// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max

SCORE
1.0
['  requires value >= min && value <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  requires IsBST(t, min, max)

SCORE
1.0
['  requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
54 | {
   |  ^

ex.dfy(54,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.

   |
55 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(55,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  requires IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.
}

ex.dfy(54,0): Error: a postcondition could not be proved on this return path
   |
54 | {
   | ^

ex.dfy(53,10): Related location: this is the postcondition that could not be proved
   |
53 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value < max &&
   |                     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['  ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  ensures IsBST(Insert(t, value), min, max)
{

   |
53 | {
   |  ^

ex.dfy(53,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.

   |
54 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(54,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires value >= min && value <= max
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.
}

ex.dfy(53,0): Error: a postcondition could not be proved on this return path
   |
53 | {
   | ^

ex.dfy(52,10): Related location: this is the postcondition that could not be proved
   |
52 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value < max &&
   |     ^^^^^^^^^^^^

ex.dfy(53,0): Error: a postcondition could not be proved on this return path
   |
53 | {
   | ^

ex.dfy(52,10): Related location: this is the postcondition that could not be proved
   |
52 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value < max &&
   |                     ^^^^^^^^^^^

ex.dfy(53,0): Error: a postcondition could not be proved on this return path
   |
53 | {
   | ^

ex.dfy(52,10): Related location: this is the postcondition that could not be proved
   |
52 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     IsBST(left, min, value) &&
   |     ^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(53,0): Error: a postcondition could not be proved on this return path
   |
53 | {
   | ^

ex.dfy(52,10): Related location: this is the postcondition that could not be proved
   |
52 |   ensures IsBST(Insert(t, value), min, max)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     IsBST(right, value, max)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 4 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree t.\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value < max && IsBST(t, min, max)

SCORE
1.0
['  requires min <= value < max && IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value < max && IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['  ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value < max && IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{

   |
53 | {
   |  ^

ex.dfy(53,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value < max && IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.

   |
54 |   // Proof by structural induction on the tree t.
   |                                                  ^

ex.dfy(54,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value < max && IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value < max && IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate that checks whether a given tree is a binary search tree (BST).
function IsBST(t: Tree, min: nat, max: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Write a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  if t == Empty then
    Node(Empty, value, Empty)
  else
    match t
    case Node(left, tValue, right) =>
      if value < tValue then
        Node(Insert(left, value), tValue, right)
      else if value > tValue then
        Node(left, tValue, Insert(right, value))
      else
        t
}

// (4) Write a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tValue, right) =>
    if value < tValue then Contains(left, value)
    else if value > tValue then Contains(right, value)
    else true
}

// (5) Write a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
lemma {:invariant true} InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree t.
}

// (6) Write another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma {:invariant true} InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
  requires min <= value < max && IsBST(t, min, max)
  ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree t.
}
```


STATS

number of nodes: 65
number of gen nodes: 33 (including leaves: 5)
number of back nodes: 32 (including leaves: 28)

expansion count: 42 (including failed: 10)

cache stats {'hit': 18, 'miss': 91}
4 minutes and 37 seconds elapsed.


