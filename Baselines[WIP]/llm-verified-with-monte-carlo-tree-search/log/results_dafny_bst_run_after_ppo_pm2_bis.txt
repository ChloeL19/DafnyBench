

========
Experiment configuration: python run.py --base_model_name ./my_dpo_model --problem_name problem_bst 


0 minutes and 0 seconds elapsed.




========
Experiment configuration: python run.py --base_model_name ./my_dpo_model --problem_name problem_bst 


[2024-01-06 17:32:20,621] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
0 minutes and 45 seconds elapsed.




========
Experiment configuration: python run.py --base_model_name ./my_dpo_model --problem_name problem_bst 


[2024-01-06 17:57:10,470] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
0 minutes and 40 seconds elapsed.




========
Experiment configuration: python run.py --base_model_name ./my_dpo_model --problem_name problem_bst 


[2024-01-06 17:58:57,169] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers

SCORE
1.0
['// (1) Define an ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree = Node(left: Tree, value: nat, right: Tree)
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['datatype Tree = Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

SCORE
1.0
['              | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree

SCORE
1.0
['// (2) Define a predicate that checks if a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t

  |
8 |   match t
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&

   |
10 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(10,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&

   |
11 |     value <= upper &&
   |                      ^

ex.dfy(11,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)

   |
12 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(12,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true

   |
13 |   case Empty => true
   |                     ^

ex.dfy(13,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree

SCORE
1.0
['// (3) Define a function that inserts an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
19 |   match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)

   |
21 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(21,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))

   |
21 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(21,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['              : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))
  case Empty => Node(Empty, value, Empty)

   |
21 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(21,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t

   |
18 |   reads t
   |         ^

ex.dfy(18,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t

   |
20 |   match t
   |          ^

ex.dfy(20,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>

   |
21 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(21,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
22 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(22,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
23 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(23,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
24 |     else t
   |           ^

ex.dfy(24,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)

   |
25 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(25,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

   |
18 |   reads t
   |         ^

ex.dfy(18,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['function Insert(t: Tree, value: nat): Tree\n']
['  reads t\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then

   |
22 |     if value < v then
   |                      ^

ex.dfy(22,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)

   |
23 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(23,41): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value == v then

   |
24 |     else if value == v then
   |                            ^

ex.dfy(24,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else if value == v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value == v then
      t

   |
25 |       t
   |        ^

ex.dfy(25,7): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value == v then
      t
    else

   |
26 |     else
   |         ^

ex.dfy(26,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value == v then
      t
    else
      Node(left, v, Insert(right, value))

   |
27 |       Node(left, v, Insert(right, value))
   |                                          ^

ex.dfy(27,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value == v then
      t
    else
      Node(left, v, Insert(right, value))
  case Empty =>

   |
28 |   case Empty =>
   |                ^

ex.dfy(28,15): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value == v then
      t
    else
      Node(left, v, Insert(right, value))
  case Empty =>
    Node(Empty, value, Empty)

   |
29 |     Node(Empty, value, Empty)
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value == v then
      t
    else
      Node(left, v, Insert(right, value))
  case Empty =>
    Node(Empty, value, Empty)
}

   |
18 |   reads t
   |         ^

ex.dfy(18,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  reads t\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    if value < v then Node(Insert(left, value), v, right)\n']
['    else if value > v then Node(left, v, Insert(right, value))\n']
['    else t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['}\n']
['// (3) Define a function that inserts an element into a binary search tree\n']
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, nat.MaxInt)

   |
18 |   requires IsBST(t, 0, nat.MaxInt)
   |                        ^

ex.dfy(18,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  requires IsBST(t, 0, nat.MaxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, nat.MaxInt)
{

   |
18 |   requires IsBST(t, 0, nat.MaxInt)
   |                        ^

ex.dfy(18,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, nat.MaxInt)
{
  match t

   |
18 |   requires IsBST(t, 0, nat.MaxInt)
   |                        ^

ex.dfy(18,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match t\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)

   |
18 |   requires IsBST(t, 0, max_nat)
   |                        ^^^^^^^

ex.dfy(18,23): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
None
['  requires IsBST(t, 0, max_nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)

   |
18 |   requires IsBST(t, 0, max_nat)
   |                        ^^^^^^^

ex.dfy(18,23): Error: unresolved identifier: max_nat
   |
19 |   ensures IsBST(t, 0, max_nat)
   |                       ^^^^^^^

ex.dfy(19,22): Error: unresolved identifier: max_nat
2 resolution/type errors detected in ex.dfy

SCORE
None
['  ensures IsBST(t, 0, max_nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t

   |
21 |   match t
   |          ^

ex.dfy(21,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Node(left, v, right) =>

   |
22 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(22,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
23 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(23,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if v < value then Node(left, v, Insert(right, value))

   |
24 |     else if v < value then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(24,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if v < value then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if v < value then Node(left, v, Insert(right, value))
    else t

   |
25 |     else t
   |           ^

ex.dfy(25,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if v < value then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)

   |
26 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(26,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if v < value then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

   |
18 |   requires IsBST(t, 0, max_nat)
   |                        ^^^^^^^

ex.dfy(18,23): Error: unresolved identifier: max_nat
   |
19 |   ensures IsBST(t, 0, max_nat)
   |                       ^^^^^^^

ex.dfy(19,22): Error: unresolved identifier: max_nat
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
['// (3) Define a function that inserts an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t

   |
19 |   match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>

   |
20 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(20,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)

   |
21 |     (if v < value then Node(Insert(left, v), value, right)
   |                                                           ^

ex.dfy(21,58): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    (if v < value then Node(Insert(left, v), value, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))

   |
22 |     else if v > value then Node(left, value, Insert(right, v))
   |                                                               ^

ex.dfy(22,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if v > value then Node(left, value, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)

   |
23 |     else t)
   |            ^

ex.dfy(23,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)

   |
24 |   case Empty => Node(Empty, v, Empty)
   |                                      ^

ex.dfy(24,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element

SCORE
1.0
['// (4) Define a predicate that checks if a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t

   |
30 |   match t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>

   |
31 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(31,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v)

   |
32 |     (v < value ? Contains(left, v)
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v < value ? Contains(left, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v)
    : v > value ? Contains(right, v)

   |
32 |     (v < value ? Contains(left, v)
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    : v > value ? Contains(right, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v)
    : v > value ? Contains(right, v)
    : true)

   |
32 |     (v < value ? Contains(left, v)
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    : true)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    (v < value ? Contains(left, v)\n']
['    : v > value ? Contains(right, v)\n']
['    : true)\n']
['predicate Contains(t: Tree, v: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v) :

   |
32 |     (v < value ? Contains(left, v) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v < value ? Contains(left, v) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v) :
     v > value ? Contains(right, v) :

   |
32 |     (v < value ? Contains(left, v) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['     v > value ? Contains(right, v) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v) :
     v > value ? Contains(right, v) :
     true)

   |
32 |     (v < value ? Contains(left, v) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['     true)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    (v < value ? Contains(left, v)\n']
['    : v > value ? Contains(right, v)\n']
['    : true)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element

SCORE
1.0
['// (4) Define a predicate that checks whether a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t

   |
30 |   match t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>

   |
31 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(31,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value ? Contains(left, v) : Contains(right, v))

   |
32 |     (v == value) || (v < value ? Contains(left, v) : Contains(right, v))
   |                                ^

ex.dfy(32,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || (v < value ? Contains(left, v) : Contains(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value ? Contains(left, v) : Contains(right, v))
  case Empty => false

   |
32 |     (v == value) || (v < value ? Contains(left, v) : Contains(right, v))
   |                                ^

ex.dfy(32,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value ? Contains(left, v) : Contains(right, v))
  case Empty => false
}

   |
32 |     (v == value) || (v < value ? Contains(left, v) : Contains(right, v))
   |                                ^

ex.dfy(32,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v)

   |
32 |     (v < value ? Contains(left, v)
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v < value ? Contains(left, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v)
    : v > value ? Contains(right, v)

   |
32 |     (v < value ? Contains(left, v)
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    : v > value ? Contains(right, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v)
    : v > value ? Contains(right, v)
    : true)

   |
32 |     (v < value ? Contains(left, v)
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    : true)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    (v < value ? Contains(left, v) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v) :
    v > value ? Contains(right, v) : true)

   |
32 |     (v < value ? Contains(left, v) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    v > value ? Contains(right, v) : true)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v < value ? Contains(left, v) :
    v > value ? Contains(right, v) : true)
  case Empty => false

   |
32 |     (v < value ? Contains(left, v) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => false\n']
['\n']
['// (4) Define a predicate that checks if a given tree contains a given element\n']
['predicate Contains(t: Tree, v: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    (v < value ? Contains(left, v)\n']
['    : v > value ? Contains(right, v)\n']
['    : true)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))

   |
32 |     (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
   |                                                                                          ^

ex.dfy(32,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false

   |
33 |   case Empty => false
   |                      ^

ex.dfy(33,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)

SCORE
1.0
['ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree

   |
41 |   // Proof is by structural recursion on the tree
   |                                                  ^

ex.dfy(41,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural recursion on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof is by structural recursion on the tree

   |
49 |   // Proof is by structural recursion on the tree
   |                                                  ^

ex.dfy(49,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural recursion on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof is by structural recursion on the tree
}

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof is by structural recursion on the tree and case analysis on the result of Insert

   |
49 |   // Proof is by structural recursion on the tree and case analysis on the result of Insert
   |                                                                                            ^

ex.dfy(49,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural recursion on the tree and case analysis on the result of Insert\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof is by structural recursion on the tree and case analysis on the result of Insert
}

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof is by structural recursion on the tree

   |
49 |   // Proof is by structural recursion on the tree
   |                                                  ^

ex.dfy(49,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof is by structural recursion on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof is by structural recursion on the tree
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof is by structural recursion on the tree
}

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t

   |
48 |   match t
   |          ^

ex.dfy(48,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>

   |
49 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(49,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {

   |
50 |     if v < value {
   |                   ^

ex.dfy(50,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertMaintainsIsBST(left, v, lower, value);

   |
51 |       InsertMaintainsIsBST(left, v, lower, value);
   |                                                   ^

ex.dfy(51,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsIsBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertMaintainsIsBST(left, v, lower, value);
    } else if v > value {

   |
52 |     } else if v > value {
   |                          ^

ex.dfy(52,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertMaintainsIsBST(left, v, lower, value);
    } else if v > value {
      InsertMaintainsIsBST(right, v, value, upper);

   |
53 |       InsertMaintainsIsBST(right, v, value, upper);
   |                                                    ^

ex.dfy(53,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsIsBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertMaintainsIsBST(left, v, lower, value);
    } else if v > value {
      InsertMaintainsIsBST(right, v, value, upper);
    }

   |
54 |     }
   |      ^

ex.dfy(54,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertMaintainsIsBST(left, v, lower, value);
    } else if v > value {
      InsertMaintainsIsBST(right, v, value, upper);
    }
  case Empty =>

   |
55 |   case Empty =>
   |                ^

ex.dfy(55,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertMaintainsIsBST(left, v, lower, value);
    } else if v > value {
      InsertMaintainsIsBST(right, v, value, upper);
    }
  case Empty =>
}

ex.dfy(55,2): Error: a postcondition could not be proved on this return path
   |
55 |   case Empty =>
   |   ^^^^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertMaintainsIsBST(left, v, lower, value);
    } else if v > value {
      InsertMaintainsIsBST(right, v, value, upper);
    }
  case Empty =>
}
``` <?php

ex.dfy(55,2): Error: a postcondition could not be proved on this return path
   |
55 |   case Empty =>
   |   ^^^^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` <?php\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` package com.github.sarxos.webcam.ds.ipcam;

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` package com.github.sarxos.webcam.ds.ipcam;\r\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value then

   |
50 |     if v < value then
   |                  ^

ex.dfy(50,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertMaintainsIsBST(left, v, lower, value)

   |
50 |     if v < value then
   |                  ^

ex.dfy(50,17): Error: lbrace expected
   |
51 |       InsertMaintainsIsBST(left, v, lower, value)
   |                                                  ^

ex.dfy(51,49): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsIsBST(left, v, lower, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertMaintainsIsBST(left, v, lower, value)
    else if v > value then

   |
50 |     if v < value then
   |                  ^

ex.dfy(50,17): Error: lbrace expected
   |
52 |     else if v > value then
   |     ^

ex.dfy(52,4): Error: invalid UpdateStmt
   |
52 |     else if v > value then
   |                       ^

ex.dfy(52,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if v > value then\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` #include <iostream>

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` #include <iostream>\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
```

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` package org.springframework.web.reactive.function.server;

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` package org.springframework.web.reactive.function.server;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
```

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['```\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t

   |
48 |   match t
   |          ^

ex.dfy(48,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>

   |
49 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(49,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value then

   |
50 |     if v < value then
   |                  ^

ex.dfy(50,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertMaintainsBST(left, v, lower, value)

   |
50 |     if v < value then
   |                  ^

ex.dfy(50,17): Error: lbrace expected
   |
51 |       InsertMaintainsBST(left, v, lower, value)
   |                                                ^

ex.dfy(51,47): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsBST(left, v, lower, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertMaintainsBST(left, v, lower, value)
    else if v > value then

   |
50 |     if v < value then
   |                  ^

ex.dfy(50,17): Error: lbrace expected
   |
52 |     else if v > value then
   |     ^

ex.dfy(52,4): Error: invalid UpdateStmt
   |
52 |     else if v > value then
   |                       ^

ex.dfy(52,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if v > value then\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` import React from 'react'

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
["``` import React from 'react'\n"]
['{\n']
['}\n']
['```\n']
['ensures Contains(Insert(t, v), v)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t

   |
41 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(41,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>

   |
43 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(43,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value

   |
44 |     // Case 1: v < value
   |                         ^

ex.dfy(44,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Case 1: v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {

   |
45 |     if v < value {
   |                   ^

ex.dfy(45,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);

   |
46 |       InsertEnsuresContains(left, v);
   |                                      ^

ex.dfy(46,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }

   |
47 |     }
   |      ^

ex.dfy(47,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value

   |
48 |     // Case 2: v > value
   |                         ^

ex.dfy(48,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Case 2: v > value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {

   |
49 |     else if v > value {
   |                        ^

ex.dfy(49,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);

   |
50 |       InsertEnsuresContains(right, v);
   |                                       ^

ex.dfy(50,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(right, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }

   |
51 |     }
   |      ^

ex.dfy(51,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>

   |
52 |   case Empty =>
   |                ^

ex.dfy(52,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value

   |
53 |     // Base case: v = value
   |                            ^

ex.dfy(53,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: v = value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
60 | {
   |  ^

ex.dfy(60,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t

   |
61 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(61,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t

   |
62 |   match t
   |          ^

ex.dfy(62,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>

   |
63 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(63,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value

   |
64 |     // Case 1: v < value
   |                         ^

ex.dfy(64,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Case 1: v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {

   |
65 |     if v < value {
   |                   ^

ex.dfy(65,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);

   |
66 |       InsertPreservesBST(left, v, lower, value);
   |                                                 ^

ex.dfy(66,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }

   |
67 |     }
   |      ^

ex.dfy(67,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }
    // Case 2: v > value

   |
68 |     // Case 2: v > value
   |                         ^

ex.dfy(68,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Case 2: v > value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }
    // Case 2: v > value
    else if v > value {

   |
69 |     else if v > value {
   |                        ^

ex.dfy(69,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }
    // Case 2: v > value
    else if v > value {
      InsertPreservesBST(right, v, value, upper);

   |
70 |       InsertPreservesBST(right, v, value, upper);
   |                                                  ^

ex.dfy(70,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }
    // Case 2: v > value
    else if v > value {
      InsertPreservesBST(right, v, value, upper);
    }

   |
71 |     }
   |      ^

ex.dfy(71,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }
    // Case 2: v > value
    else if v > value {
      InsertPreservesBST(right, v, value, upper);
    }
  case Empty =>

   |
72 |   case Empty =>
   |                ^

ex.dfy(72,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }
    // Case 2: v > value
    else if v > value {
      InsertPreservesBST(right, v, value, upper);
    }
  case Empty =>
    // Base case: v = value

   |
73 |     // Base case: v = value
   |                            ^

ex.dfy(73,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Base case: v = value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertEnsuresContains(left, v);
    }
    // Case 2: v > value
    else if v > value {
      InsertEnsuresContains(right, v);
    }
  case Empty =>
    // Base case: v = value
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on t
  match t
  case Node(left, value, right) =>
    // Case 1: v < value
    if v < value {
      InsertPreservesBST(left, v, lower, value);
    }
    // Case 2: v > value
    else if v > value {
      InsertPreservesBST(right, v, value, upper);
    }
  case Empty =>
    // Base case: v = value
}

ex.dfy(72,2): Error: a postcondition could not be proved on this return path
   |
72 |   case Empty =>
   |   ^^^^

ex.dfy(59,8): Related location: this is the postcondition that could not be proved
   |
59 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    // Case 1: v < value\n']
['    if v < value {\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    }\n']
['    // Case 2: v > value\n']
['    else if v > value {\n']
['      InsertPreservesBST(right, v, value, upper);\n']
['    }\n']
['  case Empty =>\n']
['    // Base case: v = value\n']
['}\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['{\n']
['  // Proof is by structural recursion on the tree\n']
['}\n']
['predicate Contains(t: Tree, v: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))

   |
32 |     (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
   |                                                                                          ^

ex.dfy(32,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false

   |
33 |   case Empty => false
   |                      ^

ex.dfy(33,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)

SCORE
1.0
['  ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{

   |
39 | {
   |  ^

ex.dfy(39,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t

   |
40 |   // Proof by structural induction on the input tree t
   |                                                       ^

ex.dfy(40,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the input tree t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t

   |
41 |   match t
   |          ^

ex.dfy(41,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>

   |
42 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(42,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);

   |
43 |     InsertEnsuresContains(left, v);
   |                                    ^

ex.dfy(43,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(left, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);

   |
44 |     InsertEnsuresContains(right, v);
   |                                     ^

ex.dfy(44,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(right, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>

   |
45 |   case Empty =>
   |                ^

ex.dfy(45,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t

   |
53 |   // Proof by structural induction on the input tree t
   |                                                       ^

ex.dfy(53,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the input tree t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t

   |
54 |   match t
   |          ^

ex.dfy(54,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>

   |
55 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(55,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);

   |
56 |     InsertPreservesBST(left, v, lower, value);
   |                                               ^

ex.dfy(56,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);

   |
57 |     InsertPreservesBST(right, v, value, upper);
   |                                                ^

ex.dfy(57,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>

   |
58 |   case Empty =>
   |                ^

ex.dfy(58,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` package com.yahoo.vespa.config.server.tenant;

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` package com.yahoo.vespa.config.server.tenant;\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` import { createContext, useContext } from 'react';

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
["``` import { createContext, useContext } from 'react';\n"]
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` package org.apache.camel.component.jms;

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` package org.apache.camel.component.jms;\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
```

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['```\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesBST(left, v, lower, value);

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
57 |       InsertPreservesBST(left, v, lower, value);
   |                                                 ^

ex.dfy(57,48): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesBST(left, v, lower, value);
    else if v > value then

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
58 |     else if v > value then
   |     ^

ex.dfy(58,4): Error: this symbol not expected in CaseStmt
   |
58 |     else if v > value then
   |                       ^

ex.dfy(58,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if v > value then\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    if v < value then\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    else if v > value then\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    if v < value then\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    else if v > value then\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
['```\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` import { Component } from '@angular/core';

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
["``` import { Component } from '@angular/core';\n"]
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` import { Injectable } from '@angular/core';

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
["``` import { Injectable } from '@angular/core';\n"]
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    if v < value then\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    else if v > value then\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` <?php

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` <?php\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
['```\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t

   |
53 |   // Proof by structural induction on the input tree t
   |                                                       ^

ex.dfy(53,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the input tree t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t

   |
54 |   match t
   |          ^

ex.dfy(54,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>

   |
55 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(55,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesBST(left, v, lower, value);

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
57 |       InsertPreservesBST(left, v, lower, value);
   |                                                 ^

ex.dfy(57,48): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesBST(left, v, lower, value);
    else if v > value then

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
58 |     else if v > value then
   |     ^

ex.dfy(58,4): Error: this symbol not expected in CaseStmt
   |
58 |     else if v > value then
   |                       ^

ex.dfy(58,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if v > value then\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    if v < value then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesBST(left, v, lower, value)

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
57 |       InsertPreservesBST(left, v, lower, value)
   |                                                ^

ex.dfy(57,47): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(left, v, lower, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesBST(left, v, lower, value)
    else

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
58 |     else
   |     ^

ex.dfy(58,4): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['    else\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);

   |
56 |     InsertPreservesBST(left, v, lower, value);
   |                                               ^

ex.dfy(56,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);

   |
57 |     InsertPreservesBST(right, v, value, upper);
   |                                                ^

ex.dfy(57,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>

   |
58 |   case Empty =>
   |                ^

ex.dfy(58,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` 

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` \n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` import {

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` import {\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    if v < value then\n']
['      InsertPreservesBST(left, v, lower, value);\n']
['    else if v > value then\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` #include <stdio.h>

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` #include <stdio.h>\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesBST(left, v, lower, value);\n']
['    InsertPreservesBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define another lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesBST(left, v, lower, value);
    InsertPreservesBST(right, v, value, upper);
  case Empty =>
}
``` package com.example.android.miwok;

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{

   |
52 | {
   |  ^

ex.dfy(52,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t

   |
53 |   // Proof by structural induction on the input tree t
   |                                                       ^

ex.dfy(53,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the input tree t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t

   |
54 |   match t
   |          ^

ex.dfy(54,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>

   |
55 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(55,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);

   |
56 |     InsertPreservesIsBST(left, v, lower, value);
   |                                                 ^

ex.dfy(56,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesIsBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);
    InsertPreservesIsBST(right, v, value, upper);

   |
57 |     InsertPreservesIsBST(right, v, value, upper);
   |                                                  ^

ex.dfy(57,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertPreservesIsBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);
    InsertPreservesIsBST(right, v, value, upper);
  case Empty =>

   |
58 |   case Empty =>
   |                ^

ex.dfy(58,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);
    InsertPreservesIsBST(right, v, value, upper);
  case Empty =>
}

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);
    InsertPreservesIsBST(right, v, value, upper);
  case Empty =>
}
``` package org.springframework.data.rest.core.mapping;

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` package org.springframework.data.rest.core.mapping;\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesIsBST(left, v, lower, value);\n']
['    InsertPreservesIsBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);
    InsertPreservesIsBST(right, v, value, upper);
  case Empty =>
}
``` import { createSelector } from 'reselect';

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
["``` import { createSelector } from 'reselect';\n"]
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesIsBST(left, v, lower, value);\n']
['    InsertPreservesIsBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);
    InsertPreservesIsBST(right, v, value, upper);
  case Empty =>
}
```

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['```\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesIsBST(left, v, lower, value);\n']
['    InsertPreservesIsBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
['```\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
['    InsertPreservesIsBST(left, v, lower, value);\n']
['    InsertPreservesIsBST(right, v, value, upper);\n']
['  case Empty =>\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertPreservesIsBST(left, v, lower, value);
    InsertPreservesIsBST(right, v, value, upper);
  case Empty =>
}
``` ﻿using System;

ex.dfy(58,2): Error: a postcondition could not be proved on this return path
   |
58 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` \ufeffusing System;\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {

   |
56 |     if v < value {
   |                   ^

ex.dfy(56,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertPreservesIsBST(left, v, lower, value);

   |
57 |       InsertPreservesIsBST(left, v, lower, value);
   |                                                   ^

ex.dfy(57,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesIsBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertPreservesIsBST(left, v, lower, value);
    } else if v > value {

   |
58 |     } else if v > value {
   |                          ^

ex.dfy(58,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertPreservesIsBST(left, v, lower, value);
    } else if v > value {
      InsertPreservesIsBST(right, v, value, upper);

   |
59 |       InsertPreservesIsBST(right, v, value, upper);
   |                                                    ^

ex.dfy(59,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesIsBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertPreservesIsBST(left, v, lower, value);
    } else if v > value {
      InsertPreservesIsBST(right, v, value, upper);
    }

   |
60 |     }
   |      ^

ex.dfy(60,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertPreservesIsBST(left, v, lower, value);
    } else if v > value {
      InsertPreservesIsBST(right, v, value, upper);
    }
  case Empty =>

   |
61 |   case Empty =>
   |                ^

ex.dfy(61,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertPreservesIsBST(left, v, lower, value);
    } else if v > value {
      InsertPreservesIsBST(right, v, value, upper);
    }
  case Empty =>
}

ex.dfy(61,2): Error: a postcondition could not be proved on this return path
   |
61 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value {
      InsertPreservesIsBST(left, v, lower, value);
    } else if v > value {
      InsertPreservesIsBST(right, v, value, upper);
    }
  case Empty =>
}
``` #include <stdio.h>

ex.dfy(61,2): Error: a postcondition could not be proved on this return path
   |
61 |   case Empty =>
   |   ^^^^

ex.dfy(51,10): Related location: this is the postcondition that could not be proved
   |
51 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['``` #include <stdio.h>\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
['  // Proof by structural induction on the input tree t\n']
['  match t\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesIsBST(left, v, lower, value);

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
57 |       InsertPreservesIsBST(left, v, lower, value);
   |                                                   ^

ex.dfy(57,50): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesIsBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    InsertEnsuresContains(left, v);
    InsertEnsuresContains(right, v);
  case Empty =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Proof by structural induction on the input tree t
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertPreservesIsBST(left, v, lower, value);
    else if v > value then

   |
56 |     if v < value then
   |                  ^

ex.dfy(56,17): Error: lbrace expected
   |
58 |     else if v > value then
   |     ^

ex.dfy(58,4): Error: this symbol not expected in CaseStmt
   |
58 |     else if v > value then
   |                       ^

ex.dfy(58,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if v > value then\n']
['  reads t\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)

   |
22 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(22,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))

   |
22 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(22,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['              : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))
  case Empty => Node(Empty, value, Empty)

   |
22 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(22,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Empty => Node(Empty, value, Empty)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the tree

   |
40 |   // Proof by structural induction on the tree
   |                                               ^

ex.dfy(40,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the tree
  match t

   |
41 |   match t
   |          ^

ex.dfy(41,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the tree
  match t
  case Node(left, value, right) =>

   |
42 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(42,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the tree
  match t
  case Node(left, value, right) =>
    if v < value then

   |
43 |     if v < value then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < value then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the tree
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertEnsuresContains(left, v)

   |
43 |     if v < value then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
   |
44 |       InsertEnsuresContains(left, v)
   |                                     ^

ex.dfy(44,36): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Proof by structural induction on the tree
  match t
  case Node(left, value, right) =>
    if v < value then
      InsertEnsuresContains(left, v)
    else if v > value then

   |
43 |     if v < value then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
   |
45 |     else if v > value then
   |     ^

ex.dfy(45,4): Error: invalid UpdateStmt
   |
45 |     else if v > value then
   |                       ^

ex.dfy(45,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if v > value then\n']
['  ensures Contains(Insert(t, v), v)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases

   |
40 |   // Base cases
   |                ^

ex.dfy(40,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {

   |
41 |   if t == Empty {
   |                  ^

ex.dfy(41,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {

   |
42 |   } else {
   |           ^

ex.dfy(42,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t

   |
43 |     match t
   |            ^

ex.dfy(43,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>

   |
44 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(44,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {

   |
45 |       if v == value {
   |                      ^

ex.dfy(45,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v == value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {

   |
46 |       } else if v < value {
   |                            ^

ex.dfy(46,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);

   |
47 |         InsertEnsuresContains(left, v);
   |                                        ^

ex.dfy(47,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {

   |
48 |       } else {
   |               ^

ex.dfy(48,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);

   |
49 |         InsertEnsuresContains(right, v);
   |                                         ^

ex.dfy(49,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(right, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }

   |
50 |       }
   |        ^

ex.dfy(50,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }

   |
51 |   }
   |    ^

ex.dfy(51,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{

   |
58 | {
   |  ^

ex.dfy(58,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases

   |
59 |   // Base cases
   |                ^

ex.dfy(59,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {

   |
60 |   if t == Empty {
   |                  ^

ex.dfy(60,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {

   |
61 |   } else {
   |           ^

ex.dfy(61,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t

   |
62 |     match t
   |            ^

ex.dfy(62,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>

   |
63 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(63,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {

   |
64 |       if v < value {
   |                     ^

ex.dfy(64,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);

   |
65 |         InsertPreservesBST(left, v, lower, value);
   |                                                   ^

ex.dfy(65,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {

   |
66 |       } else {
   |               ^

ex.dfy(66,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);

   |
67 |         InsertPreservesBST(right, v, value, upper);
   |                                                    ^

ex.dfy(67,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);
      }

   |
68 |       }
   |        ^

ex.dfy(68,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);
      }
  }

   |
69 |   }
   |    ^

ex.dfy(69,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);
      }
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {

   |
64 |       if v == value {
   |                      ^

ex.dfy(64,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v == value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {

   |
65 |       } else if v < value {
   |                            ^

ex.dfy(65,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertPreservesBST(left, v, lower, value);

   |
66 |         InsertPreservesBST(left, v, lower, value);
   |                                                   ^

ex.dfy(66,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {

   |
67 |       } else {
   |               ^

ex.dfy(67,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);

   |
68 |         InsertPreservesBST(right, v, value, upper);
   |                                                    ^

ex.dfy(68,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);
      }

   |
69 |       }
   |        ^

ex.dfy(69,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);
      }
  }

   |
70 |   }
   |    ^

ex.dfy(70,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else {
        InsertPreservesBST(right, v, value, upper);
      }
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else if v > value {

   |
66 |       } else if v > value {
   |                            ^

ex.dfy(66,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else if v > value {
        InsertPreservesBST(right, v, value, upper);

   |
67 |         InsertPreservesBST(right, v, value, upper);
   |                                                    ^

ex.dfy(67,51): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(right, v, value, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else if v > value {
        InsertPreservesBST(right, v, value, upper);
      }

   |
68 |       }
   |        ^

ex.dfy(68,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else if v > value {
        InsertPreservesBST(right, v, value, upper);
      }
  }

   |
69 |   }
   |    ^

ex.dfy(69,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Node(left, value, right) =>
    (if v < value then Node(Insert(left, v), value, right)
    else if v > value then Node(left, value, Insert(right, v))
    else t)
  case Empty => Node(Empty, v, Empty)
}

// (4) Define a predicate that checks whether a given tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Node(left, value, right) =>
    (v == value) || (v < value && Contains(left, v)) || (v > value && Contains(right, v))
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
  ensures Contains(Insert(t, v), v)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v == value {
      } else if v < value {
        InsertEnsuresContains(left, v);
      } else {
        InsertEnsuresContains(right, v);
      }
  }
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, v), lower, upper)
{
  // Base cases
  if t == Empty {
  } else {
    match t
    case Node(left, value, right) =>
      if v < value {
        InsertPreservesBST(left, v, lower, value);
      } else if v > value {
        InsertPreservesBST(right, v, value, upper);
      }
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(57,10): Related location: this is the postcondition that could not be proved
   |
57 |   ensures IsBST(Insert(t, v), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     value <= upper &&
   |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 

  |
7 |     reads t
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t

  |
9 |     match t
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t
    case Empty => true

   |
10 |     case Empty => true
   |                       ^

ex.dfy(10,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t
    case Empty => true
    case Node(l, v, r) =>

   |
11 |     case Node(l, v, r) =>
   |                          ^

ex.dfy(11,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= lower && v <= upper &&

   |
12 |         v >= lower && v <= upper &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        v >= lower && v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= lower && v <= upper &&
        IsBST(l, lower, v) &&

   |
13 |         IsBST(l, lower, v) &&
   |                              ^

ex.dfy(13,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(l, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= lower && v <= upper &&
        IsBST(l, lower, v) &&
        IsBST(r, v, upper)

   |
14 |         IsBST(r, v, upper)
   |                           ^

ex.dfy(14,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        IsBST(r, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t
    case Empty => true
    case Node(l, v, r) =>
        v >= lower && v <= upper &&
        IsBST(l, lower, v) &&
        IsBST(r, v, upper)
}

  |
7 |     reads t 
  |           ^

ex.dfy(7,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool

SCORE
1.0
['function IsBST(t: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t

  |
7 |   reads t
  |         ^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t

  |
9 |   match t
  |          ^

ex.dfy(9,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Empty => true

   |
10 |   case Empty => true
   |                     ^

ex.dfy(10,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>

   |
11 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(11,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&

   |
12 |     v >= min && v <= max &&
   |                            ^

ex.dfy(12,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&

   |
13 |     IsBST(l, min, v) &&
   |                        ^

ex.dfy(13,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)

   |
14 |     IsBST(r, v, max)
   |                     ^

ex.dfy(14,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
function IsBST(t: Tree, min: nat, max: nat): bool
  reads t
{
  match t
  case Empty => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

  |
7 |   reads t
  |         ^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST

SCORE
1.0
['// (2) Define a predicate to check if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree

  |
8 |   match tree
  |             ^

ex.dfy(8,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Empty => true

  |
9 |   case Empty => true
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>

   |
10 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
11 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(11,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value - 1) &&

   |
12 |     IsBST(left, lower, value - 1) &&
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value - 1) &&
    IsBST(right, value + 1, upper)

   |
13 |     IsBST(right, value + 1, upper)
   |                                   ^

ex.dfy(13,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value - 1) &&
    IsBST(right, value + 1, upper)
}

ex.dfy(12,29): Error: value does not satisfy the subset constraints of 'nat'
   |
12 |     IsBST(left, lower, value - 1) &&
   |                              ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree

  |
7 |   reads tree
  |         ^^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  decreases tree

  |
7 |   reads tree
  |         ^^^^

ex.dfy(7,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  decreases tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  decreases tree
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  decreases tree
{
  match tree

   |
10 |   match tree
   |             ^

ex.dfy(10,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  decreases tree
{
  match tree
  case Node(l, v, r) =>

   |
11 |   case Node(l, v, r) =>
   |                        ^

ex.dfy(11,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  decreases tree
{
  match tree
  case Node(l, v, r) =>
    l == Empty || IsBST(l, lower, v) &&

   |
12 |     l == Empty || IsBST(l, lower, v) &&
   |                                      ^^

ex.dfy(12,37): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
12 |     l == Empty || IsBST(l, lower, v) &&
   |                                        ^

ex.dfy(12,39): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['    l == Empty || IsBST(l, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  decreases tree
{
  match tree
  case Node(l, v, r) =>
    l == Empty || IsBST(l, lower, v) &&
    v <= upper &&

   |
12 |     l == Empty || IsBST(l, lower, v) &&
   |                                      ^^

ex.dfy(12,37): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |     v <= upper &&
   |                ^^

ex.dfy(13,15): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |     v <= upper &&
   |                  ^

ex.dfy(13,17): Error: invalid UnaryExpression
3 parse errors detected in ex.dfy

SCORE
None
['    v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  decreases tree
{
  match tree
  case Node(l, v, r) =>
    l == Empty || IsBST(l, lower, v) &&
    v <= upper &&
    r == Empty || IsBST(r, v, upper)

   |
12 |     l == Empty || IsBST(l, lower, v) &&
   |                                      ^^

ex.dfy(12,37): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
13 |     v <= upper &&
   |                ^^

ex.dfy(13,15): Error: Ambiguous use of && and ||. Use parentheses to disambiguate.
   |
14 |     r == Empty || IsBST(r, v, upper)
   |                                     ^

ex.dfy(14,36): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    r == Empty || IsBST(r, v, upper)\n']
['{\n']
['  // Base cases\n']
['  if t == Empty {\n']
['  } else {\n']
['    match t\n']
['    case Node(left, value, right) =>\n']
['      if v == value {\n']
['      } else if v < value {\n']
['        InsertPreservesBST(left, v, lower, value);\n']
['      } else {\n']
['        InsertPreservesBST(right, v, value, upper);\n']
['      }\n']
['  }\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf

SCORE
1.0
['  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST

SCORE
1.0
['// (2) Define a predicate to check if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(tree: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min &&

   |
12 |     value >= min &&
   |                    ^

ex.dfy(12,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min &&
    value <= max &&

   |
13 |     value <= max &&
   |                    ^

ex.dfy(13,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min &&
    value <= max &&
    IsBST(left, min, value - 1) &&

   |
14 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min &&
    value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
15 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min &&
    value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

ex.dfy(14,27): Error: value does not satisfy the subset constraints of 'nat'
   |
14 |     IsBST(left, min, value - 1) &&
   |                            ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  match tree\n']
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) => 

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
13 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
14 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(14,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
{
  match tree
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
} 

ex.dfy(13,27): Error: value does not satisfy the subset constraints of 'nat'
   |
13 |     IsBST(left, min, value - 1) &&
   |                            ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['} \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads min, max
  |         ^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads min, max
  |              ^^^

ex.dfy(9,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
None
['  reads min, max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t

   |
11 |   match t
   |          ^

ex.dfy(11,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
  case Leaf => true

   |
12 |   case Leaf => true
   |                    ^

ex.dfy(12,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
13 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
14 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(14,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
15 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
16 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(16,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
  reads min, max
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads min, max
  |         ^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads min, max
  |              ^^^

ex.dfy(9,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t

   |
10 |   match t
   |          ^

ex.dfy(10,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Leaf => true

   |
11 |   case Leaf => true
   |                    ^

ex.dfy(11,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
13 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(13,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
14 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
15 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  reads t
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree

SCORE
1.0
['// (2) Write a predicate to check if a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool

SCORE
1.0
['function IsBST(tree: Tree, min: nat, max: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{
  match tree
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>

   |
11 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
12 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(12,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&

   |
13 |     IsBST(left, min, value - 1) &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)

   |
14 |     IsBST(right, value + 1, max)
   |                                 ^

ex.dfy(14,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Write a predicate to check if a given tree is a binary search tree
function IsBST(tree: Tree, min: nat, max: nat): bool
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value - 1) &&
    IsBST(right, value + 1, max)
}

ex.dfy(13,27): Error: value does not satisfy the subset constraints of 'nat'
   |
13 |     IsBST(left, min, value - 1) &&
   |                            ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  match tree\n']
['  case Leaf => true\n']
['  case Node(left, value, right) =>\n']
['    value >= min && value <= max &&\n']
['    IsBST(left, min, value - 1) &&\n']
['    IsBST(right, value + 1, max)\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{
  match tree

   |
10 |   match tree
   |             ^

ex.dfy(10,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{
  match tree
  case Leaf => true

   |
11 |   case Leaf => true
   |                    ^

ex.dfy(11,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>

   |
12 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
13 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(13,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
14 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(14,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
15 |     IsBST(right, value, max)
   |                             ^

ex.dfy(15,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate to check if a tree is a BST
predicate IsBST(tree: Tree, min: nat, max: nat) 
  reads tree
{
  match tree
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['// (1) Define an ADT for a tree of natural numbers\n']
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

SCORE
1.0
['  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree

SCORE
1.0
['// (2) Define a predicate for checking if a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  requires lower <= upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t

   |
11 |   match t
   |          ^

ex.dfy(11,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t
  case Leaf => true

   |
12 |   case Leaf => true
   |                    ^

ex.dfy(12,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
13 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower &&

   |
14 |     value >= lower &&
   |                      ^

ex.dfy(14,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower &&
    value <= upper &&

   |
15 |     value <= upper &&
   |                      ^

ex.dfy(15,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower &&
    value <= upper &&
    IsBST(left, lower, value - 1) &&

   |
16 |     IsBST(left, lower, value - 1) &&
   |                                     ^

ex.dfy(16,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower &&
    value <= upper &&
    IsBST(left, lower, value - 1) &&
    IsBST(right, value + 1, upper)

   |
17 |     IsBST(right, value + 1, upper)
   |                                   ^

ex.dfy(17,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value + 1, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  requires lower <= upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower &&
    value <= upper &&
    IsBST(left, lower, value - 1) &&
    IsBST(right, value + 1, upper)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads lower, upper
  |         ^^^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads lower, upper
  |                ^^^^^

ex.dfy(9,15): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
None
['  reads lower, upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{
  match t

   |
11 |   match t
   |          ^

ex.dfy(11,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{
  match t
  case Leaf => true

   |
12 |   case Leaf => true
   |                    ^

ex.dfy(12,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

   |
13 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
14 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(14,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
15 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(15,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
16 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(16,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  reads t
  reads lower, upper
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads lower, upper
  |         ^^^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads lower, upper
  |                ^^^^^

ex.dfy(9,15): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  reads lower, upper

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads lower, upper
  |         ^^^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads lower, upper
  |                ^^^^^

ex.dfy(9,15): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
3 resolution/type errors detected in ex.dfy

SCORE
None
['  reads lower, upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  reads tree
  reads lower, upper
  reads tree.left, tree.right

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
  |
9 |   reads lower, upper
  |         ^^^^^

ex.dfy(9,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
  |
9 |   reads lower, upper
  |                ^^^^^

ex.dfy(9,15): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
   |
10 |   reads tree.left, tree.right
   |              ^^^^

ex.dfy(10,13): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
   |
10 |   reads tree.left, tree.right
   |                         ^^^^^

ex.dfy(10,24): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
5 resolution/type errors detected in ex.dfy

SCORE
-1.0
['  reads tree.left, tree.right\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{

  |
8 | {
  |  ^

ex.dfy(8,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree

  |
9 |   match tree
  |             ^

ex.dfy(9,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>

   |
10 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(10,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&

   |
11 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&

   |
12 |     value <= upper &&
   |                      ^

ex.dfy(12,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&

   |
13 |     value >= lower &&
   |                      ^

ex.dfy(13,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)

   |
14 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(14,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true

   |
15 |   case Leaf => true
   |                    ^

ex.dfy(15,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Define a function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree

SCORE
1.0
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree

   |
20 |   reads tree
   |         ^^^^

ex.dfy(20,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value

   |
20 |   reads tree
   |         ^^^^

ex.dfy(20,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
   |
21 |   reads value
   |         ^^^^^

ex.dfy(21,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
2 resolution/type errors detected in ex.dfy

SCORE
None
['  reads value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree

   |
23 |   match tree
   |             ^

ex.dfy(23,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>

   |
24 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(24,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then

   |
25 |     if value < nodeValue then
   |                              ^

ex.dfy(25,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)

   |
26 |       Node(Insert(left, value), nodeValue, right)
   |                                                  ^

ex.dfy(26,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue then

   |
27 |     else if value > nodeValue then
   |                                   ^

ex.dfy(27,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > nodeValue then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue then
      Node(left, nodeValue, Insert(right, value))

   |
28 |       Node(left, nodeValue, Insert(right, value))
   |                                                  ^

ex.dfy(28,49): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Node(left, nodeValue, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue then
      Node(left, nodeValue, Insert(right, value))
    else

   |
29 |     else
   |         ^

ex.dfy(29,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue then
      Node(left, nodeValue, Insert(right, value))
    else
      tree

   |
30 |       tree
   |           ^

ex.dfy(30,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue then
      Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Leaf =>

   |
31 |   case Leaf =>
   |               ^

ex.dfy(31,14): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue then
      Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Leaf =>
    Node(Leaf, value, Leaf)

   |
32 |     Node(Leaf, value, Leaf)
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  reads tree
  reads value
{
  match tree
  case Node(left, nodeValue, right) =>
    if value < nodeValue then
      Node(Insert(left, value), nodeValue, right)
    else if value > nodeValue then
      Node(left, nodeValue, Insert(right, value))
    else
      tree
  case Leaf =>
    Node(Leaf, value, Leaf)
}

   |
20 |   reads tree
   |         ^^^^

ex.dfy(20,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
   |
21 |   reads value
   |         ^^^^^

ex.dfy(21,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got nat)
2 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true

SCORE
1.0
['  requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)

   |
21 |   ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
   |                       ^^^^^^^

ex.dfy(21,22): Error: unresolved identifier: Min_nat
   |
21 |   ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
   |                                ^^^^^^^

ex.dfy(21,31): Error: unresolved identifier: Max_nat
   |
21 |   ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
   |                                                  ^^^^^^

ex.dfy(21,49): Error: unresolved identifier: result
   |
21 |   ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
   |                                                          ^^^^^^^

ex.dfy(21,57): Error: unresolved identifier: Min_nat
   |
21 |   ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
   |                                                                   ^^^^^^^

ex.dfy(21,66): Error: unresolved identifier: Max_nat
5 resolution/type errors detected in ex.dfy

SCORE
None
['  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
{
  match tree

   |
23 |   match tree
   |             ^

ex.dfy(23,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
{
  match tree
  case Node(left, v, right) =>

   |
24 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(24,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
{
  match tree
  case Node(left, v, right) =>
    if value < v {

   |
25 |     if value < v {
   |                  ^

ex.dfy(25,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
{
  match tree
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
25 |     if value < v {
   |                  ^

ex.dfy(25,17): Error: then expected
   |
26 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(26,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_nat, Max_nat) && IsBST(result, Min_nat, Max_nat)
{
  match tree
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
25 |     if value < v {
   |                  ^

ex.dfy(25,17): Error: then expected
   |
27 |     } else if value > v {
   |                         ^

ex.dfy(27,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_int, Max_int) => IsBST(result, Min_int, Max_int)

   |
21 |   ensures IsBST(tree, Min_int, Max_int) => IsBST(result, Min_int, Max_int)
   |                                         ^

ex.dfy(21,40): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['  ensures IsBST(tree, Min_int, Max_int) => IsBST(result, Min_int, Max_int)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_int, Max_int) => IsBST(result, Min_int, Max_int)
{

   |
21 |   ensures IsBST(tree, Min_int, Max_int) => IsBST(result, Min_int, Max_int)
   |                                         ^

ex.dfy(21,40): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
  requires true
  ensures IsBST(tree, Min_int, Max_int) => IsBST(result, Min_int, Max_int)
{
  match tree

   |
21 |   ensures IsBST(tree, Min_int, Max_int) => IsBST(result, Min_int, Max_int)
   |                                         ^

ex.dfy(21,40): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match tree\n']
['function Insert(tree: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{

   |
20 | {
   |  ^

ex.dfy(20,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree

   |
21 |   if value <= 0 then tree
   |                          ^

ex.dfy(21,25): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value <= 0 then tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else

   |
22 |   else
   |       ^

ex.dfy(22,6): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree

   |
23 |     match tree
   |               ^

ex.dfy(23,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>

   |
24 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(24,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)

   |
25 |       if value < v then Node(Insert(left, value), v, right)
   |                                                            ^

ex.dfy(25,59): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))

   |
26 |       else if value > v then Node(left, v, Insert(right, value))
   |                                                                 ^

ex.dfy(26,64): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree

   |
27 |       else tree
   |                ^

ex.dfy(27,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      else tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)

   |
28 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(28,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element

SCORE
1.0
['// (4) Define a predicate for checking if a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)

SCORE
1.0
['predicate Contains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{

   |
33 | {
   |  ^

ex.dfy(33,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree

   |
34 |   match tree
   |             ^

ex.dfy(34,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>

   |
35 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(35,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || (v > value ? Contains(left, value) : Contains(right, value))

   |
36 |     (v == value) || (v > value ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(36,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || (v > value ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || (v > value ? Contains(left, value) : Contains(right, value))
  case Leaf => false

   |
36 |     (v == value) || (v > value ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(36,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || (v > value ? Contains(left, value) : Contains(right, value))
  case Leaf => false
}

   |
36 |     (v == value) || (v > value ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(36,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))

   |
36 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(36,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
  case Leaf => false

   |
36 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(36,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
  case Leaf => false
}

   |
36 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(36,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['predicate Contains(tree: Tree, value: nat)\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)

   |
36 |     (v == value) || Contains(left, value) || Contains(right, value)
   |                                                                    ^

ex.dfy(36,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false

   |
37 |   case Leaf => false
   |                     ^

ex.dfy(37,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree

   |
44 |   // Proof by structural induction on the tree
   |                                               ^

ex.dfy(44,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree

   |
45 |   match tree
   |             ^

ex.dfy(45,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>

   |
46 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(46,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value <= 0 then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      assert Contains(tree, value);

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
   |
48 |       assert Contains(tree, value);
   |                                    ^

ex.dfy(48,35): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(tree, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      assert Contains(tree, value);
    else if value < v then

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
   |
49 |     else if value < v then
   |     ^

ex.dfy(49,4): Error: this symbol not expected in CaseStmt
   |
49 |     else if value < v then
   |                       ^

ex.dfy(49,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value < v then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the structure of the tree.

   |
44 |   // Proof by structural induction on the structure of the tree.
   |                                                                 ^

ex.dfy(44,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the structure of the tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the structure of the tree.
  // Base case: if the tree is Leaf, then it's vacuously true that the new tree contains the value.

   |
45 |   // Base case: if the tree is Leaf, then it's vacuously true that the new tree contains the value.
   |                                                                                                    ^

ex.dfy(45,99): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["  // Base case: if the tree is Leaf, then it's vacuously true that the new tree contains the value.\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the structure of the tree.
  // Base case: if the tree is Leaf, then it's vacuously true that the new tree contains the value.
  // Inductive case: if the tree is a Node, then the new tree contains the value if it's in the left subtree,

   |
46 |   // Inductive case: if the tree is a Node, then the new tree contains the value if it's in the left subtree,
   |                                                                                                              ^

ex.dfy(46,109): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["  // Inductive case: if the tree is a Node, then the new tree contains the value if it's in the left subtree,\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the structure of the tree.
  // Base case: if the tree is Leaf, then it's vacuously true that the new tree contains the value.
  // Inductive case: if the tree is a Node, then the new tree contains the value if it's in the left subtree,
  // the right subtree, or at the root.

   |
47 |   // the right subtree, or at the root.
   |                                        ^

ex.dfy(47,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // the right subtree, or at the root.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the structure of the tree.
  // Base case: if the tree is Leaf, then it's vacuously true that the new tree contains the value.
  // Inductive case: if the tree is a Node, then the new tree contains the value if it's in the left subtree,
  // the right subtree, or at the root.
}

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['  ensures Contains(Insert(tree, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree

   |
44 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(44,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree

   |
45 |   match tree
   |             ^

ex.dfy(45,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>

   |
46 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(46,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);

   |
47 |     InsertEnsuresContains(left, value);
   |                                        ^

ex.dfy(47,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);

   |
48 |     InsertEnsuresContains(right, value);
   |                                         ^

ex.dfy(48,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>

   |
49 |   case Leaf =>
   |               ^

ex.dfy(49,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>
}

ex.dfy(49,2): Error: a postcondition could not be proved on this return path
   |
49 |   case Leaf =>
   |   ^^^^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>
}


ex.dfy(49,2): Error: a postcondition could not be proved on this return path
   |
49 |   case Leaf =>
   |   ^^^^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

ex.dfy(49,2): Error: a postcondition could not be proved on this return path
   |
49 |   case Leaf =>
   |   ^^^^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree.

   |
44 |   // Proof by structural induction on tree.
   |                                            ^

ex.dfy(44,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree.
}

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)

SCORE
1.0
['ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree

   |
45 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(45,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures Contains(Insert(tree, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree

   |
46 |   match tree
   |             ^

ex.dfy(46,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>

   |
47 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(47,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then

   |
48 |     if value <= 0 then
   |                   ^

ex.dfy(48,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value <= 0 then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      // Base case: if value <= 0, then the tree is unchanged

   |
48 |     if value <= 0 then
   |                   ^

ex.dfy(48,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: if value <= 0, then the tree is unchanged\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      // Base case: if value <= 0, then the tree is unchanged
      InsertEnsuresContains(tree, value)

   |
48 |     if value <= 0 then
   |                   ^

ex.dfy(48,18): Error: lbrace expected
   |
50 |       InsertEnsuresContains(tree, value)
   |                                         ^

ex.dfy(50,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['      InsertEnsuresContains(tree, value)\n']
['ensures Contains(Insert(tree, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree

   |
45 |   // Proof by induction on tree
   |                                ^

ex.dfy(45,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree

   |
46 |   match tree
   |             ^

ex.dfy(46,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree
  case Node(left, v, right) =>

   |
47 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(47,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);

   |
48 |     InsertEnsuresContains(left, value);
   |                                        ^

ex.dfy(48,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);

   |
49 |     InsertEnsuresContains(right, value);
   |                                         ^

ex.dfy(49,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>

   |
50 |   case Leaf =>
   |               ^

ex.dfy(50,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>
}

ex.dfy(50,2): Error: a postcondition could not be proved on this return path
   |
50 |   case Leaf =>
   |   ^^^^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures Contains(Insert(tree, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>
}


ex.dfy(50,2): Error: a postcondition could not be proved on this return path
   |
50 |   case Leaf =>
   |   ^^^^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures Contains(Insert(tree, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
  // Proof by induction on tree
  match tree
  case Node(left, v, right) =>
    InsertEnsuresContains(left, value);
    InsertEnsuresContains(right, value);
  case Leaf =>
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

ex.dfy(50,2): Error: a postcondition could not be proved on this return path
   |
50 |   case Leaf =>
   |   ^^^^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures Contains(Insert(tree, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures Contains(Insert(tree, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
}


ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures Contains(Insert(tree, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
requires true
ensures Contains(Insert(tree, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,8): Related location: this is the postcondition that could not be proved
   |
43 | ensures Contains(Insert(tree, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
['{\n']
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
}

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree

   |
44 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(44,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree

   |
45 |   match tree
   |             ^

ex.dfy(45,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>

   |
46 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(46,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value <= 0 then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      assert Contains(Insert(tree, value), value);

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
   |
48 |       assert Contains(Insert(tree, value), value);
   |                                                   ^

ex.dfy(48,50): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(Insert(tree, value), value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      assert Contains(Insert(tree, value), value);
    else

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
   |
49 |     else
   |     ^

ex.dfy(49,4): Error: this symbol not expected in CaseStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['    else\n']
['{\n']
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['  ensures Contains(Insert(tree, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree

   |
44 |   // Proof by structural induction on the tree
   |                                               ^

ex.dfy(44,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree

   |
45 |   match tree
   |             ^

ex.dfy(45,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>

   |
46 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(46,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value <= 0 then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      // Base case: if value is less than or equal to 0, it is in the tree

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: if value is less than or equal to 0, it is in the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on the tree
  match tree
  case Node(left, v, right) =>
    if value <= 0 then
      // Base case: if value is less than or equal to 0, it is in the tree
      assert Contains(tree, value);

   |
47 |     if value <= 0 then
   |                   ^

ex.dfy(47,18): Error: lbrace expected
   |
49 |       assert Contains(tree, value);
   |                                    ^

ex.dfy(49,35): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      assert Contains(tree, value);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0

   |
44 |   // Base case: value is less than or equal to 0
   |                                                 ^

ex.dfy(44,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: value is less than or equal to 0\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {

   |
45 |   if value <= 0 {
   |                  ^

ex.dfy(45,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value <= 0 {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {

   |
46 |   } else {
   |           ^

ex.dfy(46,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0

   |
47 |     // Recursive case: value is greater than 0
   |                                               ^

ex.dfy(47,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: value is greater than 0\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree

   |
48 |     match tree
   |               ^

ex.dfy(48,14): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>

   |
49 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(49,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {

   |
50 |       if value < v {
   |                     ^

ex.dfy(50,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);

   |
51 |         InsertEnsuresContains(left, value);
   |                                            ^

ex.dfy(51,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {

   |
52 |       } else if value > v {
   |                            ^

ex.dfy(52,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);

   |
53 |         InsertEnsuresContains(right, value);
   |                                             ^

ex.dfy(53,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }

   |
54 |       }
   |        ^

ex.dfy(54,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
    case Leaf =>

   |
55 |     case Leaf =>
   |                 ^

ex.dfy(55,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
    case Leaf =>
  }

   |
56 |   }
   |    ^

ex.dfy(56,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Base case: value is less than or equal to 0
  if value <= 0 {
  } else {
    // Recursive case: value is greater than 0
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
    case Leaf =>
  }
}

ex.dfy(45,16): Error: a postcondition could not be proved on this return path
   |
45 |   if value <= 0 {
   |                 ^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (v == value) || Contains(left, value) || Contains(right, value)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(45,16): Error: a postcondition could not be proved on this return path
   |
45 |   if value <= 0 {
   |                 ^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 2 errors

SCORE
-1.0
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from

SCORE
1.0
['// (5) Define a lemma for the Insert function that ensures the tree resulting from\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)

SCORE
1.0
['// inserting an element contains that element (without requiring nor ensuring the BST property)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{

   |
43 | {
   |  ^

ex.dfy(43,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Contains(tree, value) <==> Contains(newTree, value)

   |
44 |   Contains(tree, value) <==> Contains(newTree, value)
   |                         ^

ex.dfy(44,24): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  Contains(tree, value) <==> Contains(newTree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Contains(tree, value) <==> Contains(newTree, value)
}

   |
44 |   Contains(tree, value) <==> Contains(newTree, value)
   |                         ^

ex.dfy(44,24): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Contains(tree, value) <==> Contains(newTree, value)
}


   |
44 |   Contains(tree, value) <==> Contains(newTree, value)
   |                         ^

ex.dfy(44,24): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
{
  Contains(tree, value) <==> Contains(newTree, value)
}

// (6) Define a lemma about the Insert function that checks the BST property

   |
44 |   Contains(tree, value) <==> Contains(newTree, value)
   |                         ^

ex.dfy(44,24): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Define a lemma about the Insert function that checks the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)

SCORE
1.0
['requires Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)

SCORE
1.0
['ensures Contains(newTree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
}


ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
}

// (6) Define a lemma about the Insert function that checks the BST property continues to hold after insertion

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['// (6) Define a lemma about the Insert function that checks the BST property continues to hold after insertion\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value

   |
46 |   // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
   |                                                                                           ^

ex.dfy(46,90): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
  match tree

   |
47 |   match tree
   |             ^

ex.dfy(47,12): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
  match tree
  case Node(left, v, right) =>

   |
48 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(48,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
  match tree
  case Node(left, v, right) =>
    match newTree

   |
49 |     match newTree
   |                  ^

ex.dfy(49,17): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match newTree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
  match tree
  case Node(left, v, right) =>
    match newTree
    case Node(nleft, nv, nright) =>

   |
50 |     case Node(nleft, nv, nright) =>
   |                                    ^

ex.dfy(50,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(nleft, nv, nright) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
  match tree
  case Node(left, v, right) =>
    match newTree
    case Node(nleft, nv, nright) =>
      if value < v then

   |
51 |       if value < v then
   |                    ^

ex.dfy(51,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
  match tree
  case Node(left, v, right) =>
    match newTree
    case Node(nleft, nv, nright) =>
      if value < v then
        InsertEnsuresContains(left, value, nleft)

   |
51 |       if value < v then
   |                    ^

ex.dfy(51,19): Error: lbrace expected
   |
52 |         InsertEnsuresContains(left, value, nleft)
   |                                                  ^

ex.dfy(52,49): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, value, nleft)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the tree is a leaf, then the new tree is a node with the inserted value
  match tree
  case Node(left, v, right) =>
    match newTree
    case Node(nleft, nv, nright) =>
      if value < v then
        InsertEnsuresContains(left, value, nleft)
      else if value > v then

   |
51 |       if value < v then
   |                    ^

ex.dfy(51,19): Error: lbrace expected
   |
53 |       else if value > v then
   |       ^

ex.dfy(53,6): Error: invalid UpdateStmt
   |
53 |       else if value > v then
   |                         ^

ex.dfy(53,24): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['      else if value > v then\n']
['ensures Contains(newTree, value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the value is in the tree, then it is in the new tree.

   |
46 |   // Base case: if the value is in the tree, then it is in the new tree.
   |                                                                         ^

ex.dfy(46,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if the value is in the tree, then it is in the new tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the value is in the tree, then it is in the new tree.
  // Inductive step: if the value is not in the tree, then it must be in either the left or the right subtree.

   |
47 |   // Inductive step: if the value is not in the tree, then it must be in either the left or the right subtree.
   |                                                                                                               ^

ex.dfy(47,110): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Inductive step: if the value is not in the tree, then it must be in either the left or the right subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: if the value is in the tree, then it is in the new tree.
  // Inductive step: if the value is not in the tree, then it must be in either the left or the right subtree.
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree

   |
46 |   // Base case: value is in tree
   |                                 ^

ex.dfy(46,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: value is in tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {

   |
47 |   if tree == newTree {
   |                       ^

ex.dfy(47,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if tree == newTree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {

   |
48 |   } else {
   |           ^

ex.dfy(48,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree

   |
49 |     match tree
   |               ^

ex.dfy(49,14): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>

   |
50 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(50,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {

   |
51 |       if value < v {
   |                     ^

ex.dfy(51,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value, newTree);

   |
52 |         InsertEnsuresContains(left, value, newTree);
   |                                                     ^

ex.dfy(52,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, value, newTree);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value, newTree);
      } else if value > v {

   |
53 |       } else if value > v {
   |                            ^

ex.dfy(53,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value, newTree);
      } else if value > v {
        InsertEnsuresContains(right, value, newTree);

   |
54 |         InsertEnsuresContains(right, value, newTree);
   |                                                      ^

ex.dfy(54,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(right, value, newTree);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value, newTree);
      } else if value > v {
        InsertEnsuresContains(right, value, newTree);
      }

   |
55 |       }
   |        ^

ex.dfy(55,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value, newTree);
      } else if value > v {
        InsertEnsuresContains(right, value, newTree);
      }
    case Leaf =>

   |
56 |     case Leaf =>
   |                 ^

ex.dfy(56,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value, newTree);
      } else if value > v {
        InsertEnsuresContains(right, value, newTree);
      }
    case Leaf =>
  }

   |
57 |   }
   |    ^

ex.dfy(57,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
  // Base case: value is in tree
  if tree == newTree {
  } else {
    match tree
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value, newTree);
      } else if value > v {
        InsertEnsuresContains(right, value, newTree);
      }
    case Leaf =>
  }
}

ex.dfy(52,8): Error: a precondition for this call could not be proved
   |
52 |         InsertEnsuresContains(left, value, newTree);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(43,9): Related location: this is the precondition that could not be proved
   |
43 | requires Contains(Insert(tree, value), value)
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (v == value) || Contains(left, value) || Contains(right, value)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(52,8): Error: a precondition for this call could not be proved
   |
52 |         InsertEnsuresContains(left, value, newTree);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(43,9): Related location: this is the precondition that could not be proved
   |
43 | requires Contains(Insert(tree, value), value)
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^

ex.dfy(53,13): Error: a postcondition could not be proved on this return path
   |
53 |       } else if value > v {
   |              ^^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^

ex.dfy(54,8): Error: a precondition for this call could not be proved
   |
54 |         InsertEnsuresContains(right, value, newTree);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(43,9): Related location: this is the precondition that could not be proved
   |
43 | requires Contains(Insert(tree, value), value)
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(36,4): Related location
   |
36 |     (v == value) || Contains(left, value) || Contains(right, value)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 3 verified, 4 errors

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(tree: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)

SCORE
1.0
['  ensures Contains(Insert(tree, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{

   |
44 | {
   |  ^

ex.dfy(44,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree

   |
45 |   // Proof by structural induction on tree
   |                                           ^

ex.dfy(45,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

ex.dfy(44,0): Error: a postcondition could not be proved on this return path
   |
44 | {
   | ^

ex.dfy(43,10): Related location: this is the postcondition that could not be proved
   |
43 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on tree\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree

SCORE
1.0
['  requires Insert(tree, value) == newTree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)

SCORE
1.0
['  ensures Contains(newTree, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // base case

   |
46 |   // base case
   |               ^

ex.dfy(46,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // base case
  if value <= 0 then

   |
47 |   if value <= 0 then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value <= 0 then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // base case
  if value <= 0 then
  {

   |
47 |   if value <= 0 then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // base case
  if value <= 0 then
  {
    assert tree == newTree;

   |
47 |   if value <= 0 then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    assert tree == newTree;\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // Base case

   |
46 |   // Base case
   |               ^

ex.dfy(46,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // Base case
  if value <= 0 then

   |
47 |   if value <= 0 then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if value <= 0 then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // Base case
  if value <= 0 then
    Insert(tree, value) == tree

   |
47 |   if value <= 0 then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Insert(tree, value) == tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
  requires Insert(tree, value) == newTree
  ensures Contains(newTree, value)
{
  // Base case
  if value <= 0 then
    Insert(tree, value) == tree
    && Contains(tree, value)

   |
47 |   if value <= 0 then
   |                 ^

ex.dfy(47,16): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    && Contains(tree, value)\n']
['  ensures Contains(Insert(tree, value), value)\n']
['{\n']
['  // Proof by structural induction on tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(tree: Tree, value: nat)
  ensures Contains(Insert(tree, value), value)
{
  // Proof by structural induction on tree
}

ex.dfy(43,0): Error: a postcondition could not be proved on this return path
   |
43 | {
   | ^

ex.dfy(42,10): Related location: this is the postcondition that could not be proved
   |
42 |   ensures Contains(Insert(tree, value), value)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Leaf => false
}

// (5) Define a lemma for the Insert function that ensures the tree resulting from
// inserting an element contains that element (without requiring nor ensuring the BST property)
lemma InsertEnsuresContains(tree: Tree, value: nat, newTree: Tree)
requires Contains(Insert(tree, value), value)
ensures Contains(newTree, value)
{
}

// (6) Define a lemma for the Insert function that checks the BST property continues to hold

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures Contains(newTree, value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(37,15): Related location
   |
37 |   case Leaf => false
   |                ^^^^^


Dafny program verifier finished with 3 verified, 1 error

SCORE
-1.0
['// (6) Define a lemma for the Insert function that checks the BST property continues to hold\n']
['{\n']
['  match tree\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) ||

   |
36 |     (v == value) ||
   |                    ^

ex.dfy(36,19): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) ||\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) ||
    (value < v ? Contains(left, value) : Contains(right, value))

   |
37 |     (value < v ? Contains(left, value) : Contains(right, value))
   |                ^

ex.dfy(37,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) ||
    (value < v ? Contains(left, value) : Contains(right, value))
  case Leaf => false

   |
37 |     (value < v ? Contains(left, value) : Contains(right, value))
   |                ^

ex.dfy(37,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Define a predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
{
  match tree
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    value >= lower &&
    IsBST(right, value, upper)
  case Leaf => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(tree: Tree, value: nat): Tree
{
  if value <= 0 then tree
  else
    match tree
    case Node(left, v, right) =>
      if value < v then Node(Insert(left, value), v, right)
      else if value > v then Node(left, v, Insert(right, value))
      else tree
    case Leaf => Node(Leaf, value, Leaf)
}

// (4) Define a predicate for checking if a given tree contains a given element
predicate Contains(tree: Tree, value: nat)
{
  match tree
  case Node(left, v, right) =>
    (v == value) ||
    (value < v ? Contains(left, value) : Contains(right, value))
  case Leaf => false
}

   |
37 |     (value < v ? Contains(left, value) : Contains(right, value))
   |                ^

ex.dfy(37,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree

SCORE
1.0
['// (2) Define a predicate for checking if a tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
8 |   match t
  |          ^

ex.dfy(8,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&

   |
10 |     value > min && value < max &&
   |                                  ^

ex.dfy(10,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value > min && value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
12 |     IsBST(right, value, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true

   |
13 |   case Empty => true
   |                     ^

ex.dfy(13,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Define a function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
19 |   match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
21 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(21,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
22 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(22,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
23 |     else t
   |           ^

ex.dfy(23,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)

   |
24 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(24,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element

SCORE
1.0
['// (4) Define a predicate for checking if a tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t

   |
30 |   match t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>

   |
31 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(31,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :

   |
32 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v ? Contains(left, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :
     value > v ? Contains(right, value) :

   |
32 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['     value > v ? Contains(right, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :
     value > v ? Contains(right, value) :
     true)

   |
32 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['     true)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v ? Contains(left, value) :\n']
['     value > v ? Contains(right, value) :\n']
['     true)\n']
['predicate Contains(t: Tree, value: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Contains(left, value)

   |
32 |     (value < v) ? Contains(left, value)
   |                 ^

ex.dfy(32,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v) ? Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Contains(left, value)
               : (value > v) ? Contains(right, value)

   |
32 |     (value < v) ? Contains(left, value)
   |                 ^

ex.dfy(32,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['               : (value > v) ? Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Contains(left, value)
               : (value > v) ? Contains(right, value)
                            : true

   |
32 |     (value < v) ? Contains(left, value)
   |                 ^

ex.dfy(32,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                            : true\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v ? Contains(left, value) :\n']
['     value > v ? Contains(right, value) :\n']
['     true)\n']
['// (4) Define a predicate for checking if a tree contains a given element\n']
['predicate Contains(t: Tree, value: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    value == v ? true

   |
32 |     value == v ? true
   |                ^

ex.dfy(32,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    value == v ? true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    value == v ? true
             : value < v ? Contains(left, value)

   |
32 |     value == v ? true
   |                ^

ex.dfy(32,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : value < v ? Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    value == v ? true
             : value < v ? Contains(left, value)
                        : Contains(right, value)

   |
32 |     value == v ? true
   |                ^

ex.dfy(32,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                        : Contains(right, value)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v ? Contains(left, value) :\n']
['     value > v ? Contains(right, value) :\n']
['     true)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))

   |
32 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(32,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
  case Empty => false

   |
32 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(32,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
  case Empty => false
}

   |
32 |     (v == value) || (value < v ? Contains(left, value) : Contains(right, value))
   |                                ^

ex.dfy(32,31): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
['// (4) Define a predicate for checking if a tree contains a given element\n']
['predicate Contains(t: Tree, value: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    value == v ? true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    value == v ? true
    else if value < v then Contains(left, value)

   |
32 |     value == v ? true
   |                ^

ex.dfy(32,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value < v then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    value == v ? true
    else if value < v then Contains(left, value)
    else Contains(right, value)

   |
32 |     value == v ? true
   |                ^

ex.dfy(32,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    else Contains(right, value)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)

   |
32 |     (v == value) || Contains(left, value) || Contains(right, value)
   |                                                                    ^

ex.dfy(32,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false

   |
33 |   case Empty => false
   |                      ^

ex.dfy(33,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t

   |
41 |   // Proof by induction on the structure of t
   |                                              ^

ex.dfy(41,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Node(left, v, right) =>

   |
43 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(43,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Node(left, v, right) =>
    if value < v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
45 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(45,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of t
  match t
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)
    else if value > v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
46 |     else if value > v then
   |     ^

ex.dfy(46,4): Error: invalid UpdateStmt
   |
46 |     else if value > v then
   |                       ^

ex.dfy(46,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package com.example.android.miwok;

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` ﻿using System;

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` \ufeffusing System;\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['``` \ufeffusing System;\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import React, { Component } from "react";

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import React, { Component } from "react";\n']
['{\n']
['}\n']
['```\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #include "stdafx.h"

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include "stdafx.h"\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #ifndef _CARTO_MAPNIKVT_SYMBOLIZERCONTEXT_H_

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #ifndef _CARTO_MAPNIKVT_SYMBOLIZERCONTEXT_H_\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package org.apache.hadoop.hive.ql.exec.vector.expressions;

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.hadoop.hive.ql.exec.vector.expressions;\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` <?php

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` <?php\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #include <stdio.h>

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include <stdio.h>\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { Component, OnInit, Input } from '@angular/core';

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Component, OnInit, Input } from '@angular/core';\n"]
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
["``` import { Component, OnInit, Input } from '@angular/core';\n"]
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the shape of the tree

   |
41 |   // Proof by structural induction on the shape of the tree
   |                                                            ^

ex.dfy(41,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the shape of the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the shape of the tree
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the shape of the tree
  match t
  case Node(left, v, right) =>

   |
43 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(43,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the shape of the tree
  match t
  case Node(left, v, right) =>
    if value < v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the shape of the tree
  match t
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
45 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(45,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the shape of the tree
  match t
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)
    else if value > v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
46 |     else if value > v then
   |     ^

ex.dfy(46,4): Error: invalid UpdateStmt
   |
46 |     else if value > v then
   |                       ^

ex.dfy(46,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['requires true\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree

   |
41 |   // Proof by structural induction on the tree
   |                                               ^

ex.dfy(41,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree

   |
42 |   // Base case: Empty tree
   |                           ^

ex.dfy(42,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: Empty tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {

   |
43 |   if t == Empty {
   |                  ^

ex.dfy(43,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {

   |
44 |   } else {
   |           ^

ex.dfy(44,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma

   |
45 |     // Inductive step: Recursive call to lemma
   |                                               ^

ex.dfy(45,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive step: Recursive call to lemma\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t

   |
46 |     match t
   |            ^

ex.dfy(46,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>

   |
47 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(47,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);

   |
48 |       InsertEnsuresContains(left, value);
   |                                          ^

ex.dfy(48,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);

   |
49 |       InsertEnsuresContains(right, value);
   |                                           ^

ex.dfy(49,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }

   |
50 |   }
   |    ^

ex.dfy(50,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
57 | {
   |  ^

ex.dfy(57,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree

   |
58 |   // Proof by structural induction on the tree
   |                                               ^

ex.dfy(58,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree

   |
59 |   // Base case: Empty tree
   |                           ^

ex.dfy(59,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: Empty tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {

   |
60 |   if t == Empty {
   |                  ^

ex.dfy(60,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {

   |
61 |   } else {
   |           ^

ex.dfy(61,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma

   |
62 |     // Inductive step: Recursive call to lemma
   |                                               ^

ex.dfy(62,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive step: Recursive call to lemma\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t

   |
63 |     match t
   |            ^

ex.dfy(63,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>

   |
64 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(64,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {

   |
65 |       if value < v {
   |                     ^

ex.dfy(65,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);

   |
66 |         InsertMaintainsBST(left, value, min, v);
   |                                                 ^

ex.dfy(66,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {

   |
67 |       } else if value > v {
   |                            ^

ex.dfy(67,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);

   |
68 |         InsertMaintainsBST(right, value, v, max);
   |                                                  ^

ex.dfy(68,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);
      }

   |
69 |       }
   |        ^

ex.dfy(69,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);
      }
  }

   |
70 |   }
   |    ^

ex.dfy(70,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);
      }
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);

   |
65 |       InsertMaintainsBST(left, value, min, v);
   |                                               ^

ex.dfy(65,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);
      InsertMaintainsBST(right, value, v, max);

   |
66 |       InsertMaintainsBST(right, value, v, max);
   |                                                ^

ex.dfy(66,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);
      InsertMaintainsBST(right, value, v, max);
  }

   |
67 |   }
   |    ^

ex.dfy(67,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);
      InsertMaintainsBST(right, value, v, max);
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max

SCORE
1.0
['requires IsBST(t, min, max) && min <= value && value <= max\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{

   |
57 | {
   |  ^

ex.dfy(57,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree

   |
58 |   // Proof by structural induction on the tree
   |                                               ^

ex.dfy(58,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree

   |
59 |   // Base case: Empty tree
   |                           ^

ex.dfy(59,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: Empty tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {

   |
60 |   if t == Empty {
   |                  ^

ex.dfy(60,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {

   |
61 |   } else {
   |           ^

ex.dfy(61,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma

   |
62 |     // Inductive step: Recursive call to lemma
   |                                               ^

ex.dfy(62,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive step: Recursive call to lemma\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t

   |
63 |     match t
   |            ^

ex.dfy(63,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>

   |
64 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(64,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {

   |
65 |       if value < v {
   |                     ^

ex.dfy(65,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);

   |
66 |         InsertMaintainsBST(left, value, min, v);
   |                                                 ^

ex.dfy(66,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {

   |
67 |       } else if value > v {
   |                            ^

ex.dfy(67,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);

   |
68 |         InsertMaintainsBST(right, value, v, max);
   |                                                  ^

ex.dfy(68,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);
      }

   |
69 |       }
   |        ^

ex.dfy(69,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);
      }
  }

   |
70 |   }
   |    ^

ex.dfy(70,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, min, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, max);
      }
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);

   |
65 |       InsertMaintainsBST(left, value, min, v);
   |                                               ^

ex.dfy(65,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);
      InsertMaintainsBST(right, value, v, max);

   |
66 |       InsertMaintainsBST(right, value, v, max);
   |                                                ^

ex.dfy(66,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);
      InsertMaintainsBST(right, value, v, max);
  }

   |
67 |   }
   |    ^

ex.dfy(67,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max) && min <= value && value <= max
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertMaintainsBST(left, value, min, v);
      InsertMaintainsBST(right, value, v, max);
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(65,6): Error: a precondition for this call could not be proved
   |
65 |       InsertMaintainsBST(left, value, min, v);
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(55,47): Related location: this is the precondition that could not be proved
   |
55 | requires IsBST(t, min, max) && min <= value && value <= max
   |                                                ^^^^^^^^^^^^

ex.dfy(66,6): Error: a precondition for this call could not be proved
   |
66 |       InsertMaintainsBST(right, value, v, max);
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(55,31): Related location: this is the precondition that could not be proved
   |
55 | requires IsBST(t, min, max) && min <= value && value <= max
   |                                ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 4 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
57 | {
   |  ^

ex.dfy(57,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree

   |
58 |   // Proof by structural induction on the tree
   |                                               ^

ex.dfy(58,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree

   |
59 |   // Base case: Empty tree
   |                           ^

ex.dfy(59,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: Empty tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {

   |
60 |   if t == Empty {
   |                  ^

ex.dfy(60,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {

   |
61 |   } else {
   |           ^

ex.dfy(61,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma

   |
62 |     // Inductive step: Recursive call to lemma
   |                                               ^

ex.dfy(62,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Inductive step: Recursive call to lemma\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t

   |
63 |     match t
   |            ^

ex.dfy(63,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>

   |
64 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(64,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertPreservesBST(left, value, min, v);

   |
65 |       InsertPreservesBST(left, value, min, v);
   |                                               ^

ex.dfy(65,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertPreservesBST(left, value, min, v);
      InsertPreservesBST(right, value, v, max);

   |
66 |       InsertPreservesBST(right, value, v, max);
   |                                                ^

ex.dfy(66,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertPreservesBST(left, value, min, v);
      InsertPreservesBST(right, value, v, max);
  }

   |
67 |   }
   |    ^

ex.dfy(67,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertPreservesBST(left, value, min, v);
      InsertPreservesBST(right, value, v, max);
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {

   |
65 |       if value < v {
   |                     ^

ex.dfy(65,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, min, v);

   |
66 |         InsertPreservesBST(left, value, min, v);
   |                                                 ^

ex.dfy(66,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(left, value, min, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, min, v);
      } else if value > v {

   |
67 |       } else if value > v {
   |                            ^

ex.dfy(67,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, min, v);
      } else if value > v {
        InsertPreservesBST(right, value, v, max);

   |
68 |         InsertPreservesBST(right, value, v, max);
   |                                                  ^

ex.dfy(68,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesBST(right, value, v, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, min, v);
      } else if value > v {
        InsertPreservesBST(right, value, v, max);
      }

   |
69 |       }
   |        ^

ex.dfy(69,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, min, v);
      } else if value > v {
        InsertPreservesBST(right, value, v, max);
      }
  }

   |
70 |   }
   |    ^

ex.dfy(70,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      InsertEnsuresContains(left, value);
      InsertEnsuresContains(right, value);
  }
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Proof by structural induction on the tree
  // Base case: Empty tree
  if t == Empty {
  } else {
    // Inductive step: Recursive call to lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesBST(left, value, min, v);
      } else if value > v {
        InsertPreservesBST(right, value, v, max);
      }
  }
}

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^

ex.dfy(60,16): Error: a postcondition could not be proved on this return path
   |
60 |   if t == Empty {
   |                 ^

ex.dfy(56,8): Related location: this is the postcondition that could not be proved
   |
56 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      InsertPreservesBST(left, value, min, v);\n']
['      InsertPreservesBST(right, value, v, max);\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertPreservesBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertPreservesBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
['  // Proof by structural induction on the tree\n']
['  // Base case: Empty tree\n']
['  if t == Empty {\n']
['  } else {\n']
['    // Inductive step: Recursive call to lemma\n']
['    match t\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, min, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, max);\n']
['      }\n']
['  }\n']
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t

   |
41 |   // Proof by induction on the structure of the tree t
   |                                                       ^

ex.dfy(41,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of the tree t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t
  match t
  case Node(left, v, right) =>

   |
43 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(43,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t
  match t
  case Node(left, v, right) =>
    if value < v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t
  match t
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
45 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(45,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Lemma about the insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t
  match t
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)
    else if value > v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
46 |     else if value > v then
   |     ^

ex.dfy(46,4): Error: invalid UpdateStmt
   |
46 |     else if value > v then
   |                       ^

ex.dfy(46,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['predicate Contains(t: Tree, value: nat)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (v == value) || (value < v ? Contains(left, value) : Contains(right, value))\n']
['  case Empty => false\n']
['}\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (v == value) || Contains(left, value) || Contains(right, value)\n']
['  case Empty => false\n']
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())

   |
38 | requires IsBST(t, 0, max_nat())
   |                      ^^^^^^^

ex.dfy(38,21): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
None
['requires IsBST(t, 0, max_nat())\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)

   |
38 | requires IsBST(t, 0, max_nat())
   |                      ^^^^^^^

ex.dfy(38,21): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
None
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value

   |
41 |   // Base case: if the tree is empty, the new tree contains the value
   |                                                                      ^

ex.dfy(41,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: if the tree is empty, the new tree contains the value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {

   |
42 |   if t == Empty {
   |                  ^

ex.dfy(42,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {

   |
43 |   } else {
   |           ^

ex.dfy(43,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma

   |
44 |     // Recursive case: analyze the structure of the tree and recursively call the lemma
   |                                                                                        ^

ex.dfy(44,87): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: analyze the structure of the tree and recursively call the lemma\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t

   |
45 |     match t
   |            ^

ex.dfy(45,11): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>

   |
46 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(46,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>
      if value < v {

   |
47 |       if value < v {
   |                     ^

ex.dfy(47,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);

   |
48 |         InsertEnsuresContains(left, value);
   |                                            ^

ex.dfy(48,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {

   |
49 |       } else if value > v {
   |                            ^

ex.dfy(49,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);

   |
50 |         InsertEnsuresContains(right, value);
   |                                             ^

ex.dfy(50,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }

   |
51 |       }
   |        ^

ex.dfy(51,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }

   |
52 |   }
   |    ^

ex.dfy(52,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, max_nat())
ensures Contains(Insert(t, value), value)
{
  // Base case: if the tree is empty, the new tree contains the value
  if t == Empty {
  } else {
    // Recursive case: analyze the structure of the tree and recursively call the lemma
    match t
    case Node(left, v, right) =>
      if value < v {
        InsertEnsuresContains(left, value);
      } else if value > v {
        InsertEnsuresContains(right, value);
      }
  }
}

   |
38 | requires IsBST(t, 0, max_nat())
   |                      ^^^^^^^

ex.dfy(38,21): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { Injectable } from '@nestjs/common';

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Injectable } from '@nestjs/common';\n"]
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { Component, OnInit } from '@angular/core';

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Component, OnInit } from '@angular/core';\n"]
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { useEffect, useState } from "react";

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import { useEffect, useState } from "react";\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #include "pch.h"

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include "pch.h"\n']
['{\n']
['}\n']
['```\n']
['\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package org.apache.ignite.internal.processors.query.calcite.prepare;

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.ignite.internal.processors.query.calcite.prepare;\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { Injectable } from '@angular/core';

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Injectable } from '@angular/core';\n"]
['{\n']
['}\n']
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
  reads t

   |
18 |   reads t
   |         ^

ex.dfy(18,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
  reads t
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
  reads t
{
  match t

   |
20 |   match t
   |          ^

ex.dfy(20,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
  reads t
{
  match t
  case Node(left, value, right) =>

   |
21 |   case Node(left, value, right) =>
   |                                   ^

ex.dfy(21,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
  reads t
{
  match t
  case Node(left, value, right) =>
    (v < value) ? Node(Insert(left, v), value, right)

   |
22 |     (v < value) ? Node(Insert(left, v), value, right)
   |                 ^

ex.dfy(22,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v < value) ? Node(Insert(left, v), value, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
  reads t
{
  match t
  case Node(left, value, right) =>
    (v < value) ? Node(Insert(left, v), value, right)
             : (v > value) ? Node(left, value, Insert(right, v))

   |
22 |     (v < value) ? Node(Insert(left, v), value, right)
   |                 ^

ex.dfy(22,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : (v > value) ? Node(left, value, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
  reads t
{
  match t
  case Node(left, value, right) =>
    (v < value) ? Node(Insert(left, v), value, right)
             : (v > value) ? Node(left, value, Insert(right, v))
                          : t

   |
22 |     (v < value) ? Node(Insert(left, v), value, right)
   |                 ^

ex.dfy(22,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                          : t\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node

   |
48 |   // Base case: If the tree is empty, the result is a tree with a single node
   |                                                                              ^

ex.dfy(48,77): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base case: If the tree is empty, the result is a tree with a single node\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node
  if t == Empty {

   |
49 |   if t == Empty {
   |                  ^

ex.dfy(49,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node
  if t == Empty {
  } else {

   |
50 |   } else {
   |           ^

ex.dfy(50,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node
  if t == Empty {
  } else {
    // Recursive case: The function recursively calls itself on the left and right subtrees

   |
51 |     // Recursive case: The function recursively calls itself on the left and right subtrees
   |                                                                                            ^

ex.dfy(51,91): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    // Recursive case: The function recursively calls itself on the left and right subtrees\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node
  if t == Empty {
  } else {
    // Recursive case: The function recursively calls itself on the left and right subtrees
    InsertMaintainsIsBST(t.left, value, min, t.value);

   |
52 |     InsertMaintainsIsBST(t.left, value, min, t.value);
   |                                                       ^

ex.dfy(52,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertMaintainsIsBST(t.left, value, min, t.value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node
  if t == Empty {
  } else {
    // Recursive case: The function recursively calls itself on the left and right subtrees
    InsertMaintainsIsBST(t.left, value, min, t.value);
    InsertMaintainsIsBST(t.right, value, t.value, max);

   |
53 |     InsertMaintainsIsBST(t.right, value, t.value, max);
   |                                                        ^

ex.dfy(53,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    InsertMaintainsIsBST(t.right, value, t.value, max);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node
  if t == Empty {
  } else {
    // Recursive case: The function recursively calls itself on the left and right subtrees
    InsertMaintainsIsBST(t.left, value, min, t.value);
    InsertMaintainsIsBST(t.right, value, t.value, max);
  }

   |
54 |   }
   |    ^

ex.dfy(54,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
  // Base case: If the tree is empty, the result is a tree with a single node
  if t == Empty {
  } else {
    // Recursive case: The function recursively calls itself on the left and right subtrees
    InsertMaintainsIsBST(t.left, value, min, t.value);
    InsertMaintainsIsBST(t.right, value, t.value, max);
  }
}

ex.dfy(49,16): Error: a postcondition could not be proved on this return path
   |
49 |   if t == Empty {
   |                 ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^

ex.dfy(49,16): Error: a postcondition could not be proved on this return path
   |
49 |   if t == Empty {
   |                 ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Node(left, value, right) =>
    value > min && value < max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
  case Empty => true
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package com.example.android.miwok;

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,19): Related location
   |
10 |     value > min && value < max &&
   |                    ^^^^^^^^^^^

ex.dfy(47,0): Error: a postcondition could not be proved on this return path
   |
47 | {
   | ^

ex.dfy(46,8): Related location: this is the postcondition that could not be proved
   |
46 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value > min && value < max &&
   |     ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['{\n']
['}\n']
['```\n']
['// (3) Define a function that inserts an element into a binary search tree\n']
['function Insert(t: Tree, value: nat): Tree\n']
['  reads t\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then

   |
24 |     else if value > v then
   |                           ^

ex.dfy(24,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))

   |
25 |       Node(left, v, Insert(right, value))
   |                                          ^

ex.dfy(25,41): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['      Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else

   |
26 |     else
   |         ^

ex.dfy(26,8): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t

   |
27 |       t
   |        ^

ex.dfy(27,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
  case Empty =>

   |
28 |   case Empty =>
   |                ^

ex.dfy(28,15): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
  case Empty =>
    Node(Empty, value, Empty)

   |
29 |     Node(Empty, value, Empty)
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
  reads t
{
  match t
  case Node(left, v, right) =>
    if value < v then
      Node(Insert(left, value), v, right)
    else if value > v then
      Node(left, v, Insert(right, value))
    else
      t
  case Empty =>
    Node(Empty, value, Empty)
}

   |
18 |   reads t
   |         ^

ex.dfy(18,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
21 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(21,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
22 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(22,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
23 |     else t
   |           ^

ex.dfy(23,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)

   |
24 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(24,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element

SCORE
1.0
['// (4) Define a predicate that checks if a given tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t

   |
30 |   match t
   |          ^

ex.dfy(30,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>

   |
31 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(31,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :

   |
32 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v ? Contains(left, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :
     value > v ? Contains(right, value) :

   |
32 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['     value > v ? Contains(right, value) :\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (value < v ? Contains(left, value) :
     value > v ? Contains(right, value) :
     true)

   |
32 |     (value < v ? Contains(left, value) :
   |                ^

ex.dfy(32,15): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['     true)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)

   |
32 |     (v == value) || Contains(left, value) || Contains(right, value)
   |                                                                    ^

ex.dfy(32,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (v == value) || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false

   |
33 |   case Empty => false
   |                      ^

ex.dfy(33,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.

SCORE
1.0
['// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper) && lower <= value <= upper

SCORE
1.0
['requires IsBST(t, lower, upper) && lower <= value <= upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper) && lower <= value <= upper
ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper) && lower <= value <= upper
ensures IsBST(Insert(t, value), lower, upper)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper) && lower <= value <= upper
ensures IsBST(Insert(t, value), lower, upper)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper) && lower <= value <= upper
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity;

SCORE
1.0
['``` package org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity;\n']
CHOSEN SOLUTION
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree of natural numbers
datatype Tree = Node(left: Tree, value: nat, right: Tree)
              | Empty

// (2) Define a predicate that checks if a given tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    value <= upper &&
    IsBST(right, value, upper)
  case Empty => true
}

// (3) Define a function that inserts an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
  case Empty => Node(Empty, value, Empty)
}

// (4) Define a predicate that checks if a given tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Node(left, v, right) =>
    (v == value) || Contains(left, value) || Contains(right, value)
  case Empty => false
}

// (5) Define a lemma about the Insert function that ensures that the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define another lemma about the Insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper) && lower <= value <= upper
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity;


STATS

number of nodes: 637
number of gen nodes: 319 (including leaves: 102)
number of back nodes: 318 (including leaves: 217)

expansion count: 552 (including failed: 234)

cache stats {'hit': 1150, 'miss': 918}
65 minutes and 25 seconds elapsed.


